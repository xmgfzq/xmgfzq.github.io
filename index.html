<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>æ‹¼è±†é€æ ¼é«˜äº®åŠ©æ‰‹ï¼ˆMardï¼‰</title>
    <style>
        :root {
            --bg: #0b0c10;
            --panel: #12141b;
            --panel2: #0f1117;
            --text: #e8eaf0;
            --muted: #a7adbd;
            --line: #2a2f3b;
            --accent: #7aa2ff;
            --danger: #ff5d5d;
            --ok: #42d392;
            --shadow: 0 10px 30px rgba(0, 0, 0, .35);
            --radius: 16px;
            --btnh: 46px;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            color: var(--text);
            background: radial-gradient(1200px 800px at 20% -10%, rgba(122, 162, 255, .20), transparent 60%),
                radial-gradient(1000px 700px at 110% 10%, rgba(66, 211, 146, .12), transparent 60%), var(--bg);
            overflow: hidden;
        }

        /* ====== é˜²æ­¢ iOS / å¹³æ¿ï¼šç‚¹è¾“å…¥æ¡†æ”¾å¤§ & è¿ç‚¹æŒ‰é’®æ”¾å¤§ ====== */
        input,
        select,
        textarea {
            font-size: 16px;
        }

        button,
        .btn,
        .fabBtn,
        .fabMain,
        .colorItem,
        .pill,
        .chip {
            touch-action: manipulation;
        }

        /* ====== ä¸Šä¸‹åˆ†æ ï¼šé¢æ¿åœ¨ä¸Šï¼Œç”»å¸ƒåœ¨ä¸‹ï¼ˆä¸å†å·¦å³åˆ†æ ï¼‰ ====== */
        .app {
            height: 100dvh;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 12px;
            padding-bottom: calc(12px + env(safe-area-inset-bottom));
            min-height: 0;
        }

        /* åˆ†æ éšè—æ¨¡å¼ */
        body.panelHidden .app {
            gap: 0;
        }

        body.panelHidden .side {
            display: none !important;
        }

        .card {
            background: linear-gradient(180deg, rgba(18, 20, 27, .92), rgba(12, 14, 20, .92));
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden
        }

        /* é¡¶éƒ¨é¢æ¿ï¼šé™åˆ¶é«˜åº¦ï¼Œå†…å®¹å†…éƒ¨æ»šåŠ¨ */
        .side {
            display: flex;
            flex-direction: column;
            min-height: 0;
            max-height: 24dvh;
        }

        @media (max-height:720px) {
            .side {
                max-height: 24dvh;
            }
        }

        @media (max-width:980px) {
            .side {
                max-height: 24dvh;
            }
        }

        .header {
            padding: 14px 14px 10px 14px;
            border-bottom: 1px solid rgba(255, 255, 255, .08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px
        }

        .title {
            display: flex;
            flex-direction: column;
            gap: 2px
        }

        .title b {
            font-size: 14px;
            letter-spacing: .2px
        }

        .title small {
            font-size: 12px;
            color: var(--muted)
        }

        .chip {
            font-size: 12px;
            color: #cdd3e6;
            background: rgba(122, 162, 255, .12);
            border: 1px solid rgba(122, 162, 255, .25);
            padding: 6px 10px;
            border-radius: 999px;
            white-space: nowrap
        }

        .content {
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            overflow: auto;
            /* é¡¶éƒ¨é¢æ¿å†…éƒ¨æ»šåŠ¨ */
            padding-bottom: 14px;
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }

        label {
            font-size: 12px;
            color: var(--muted)
        }

        input[type="file"],
        input[type="number"],
        input[type="text"],
        select {
            background: rgba(255, 255, 255, .06);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, .10);
            border-radius: 12px;
            padding: 10px 12px;
            outline: none;
            width: 100%
        }

        input[type="number"] {
            padding: 10px 10px
        }

        .grid2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px
        }

        .btn {
            height: var(--btnh);
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(255, 255, 255, .06);
            color: var(--text);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 0 14px;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-weight: 600;
            letter-spacing: .2px
        }

        .btn:active {
            transform: translateY(1px)
        }

        .btn.primary {
            background: rgba(122, 162, 255, .18);
            border-color: rgba(122, 162, 255, .35)
        }

        .btn.ok {
            background: rgba(66, 211, 146, .16);
            border-color: rgba(66, 211, 146, .30)
        }

        .btn.danger {
            background: rgba(255, 93, 93, .14);
            border-color: rgba(255, 93, 93, .25)
        }

        .btn.small {
            height: 38px;
            border-radius: 12px;
            font-size: 13px
        }

        .btn.wide {
            width: 100%
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 14px;
            background: rgba(0, 0, 0, .15)
        }

        .toggle input {
            width: 18px;
            height: 18px
        }

        .hr {
            height: 1px;
            background: rgba(255, 255, 255, .08);
            margin: 4px 0
        }

        .colors {
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 8px
        }

        .colorsTop {
            display: flex;
            gap: 10px;
            align-items: center
        }

        .colorsTop input {
            flex: 1
        }

        .list {
            min-height: 0;
            overflow: auto;
            padding-right: 4px
        }

        .colorItem {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 10px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, .08);
            background: rgba(0, 0, 0, .12);
            cursor: pointer;
            margin-bottom: 8px
        }

        .colorItem.active {
            border-color: rgba(122, 162, 255, .45);
            box-shadow: 0 0 0 2px rgba(122, 162, 255, .14) inset;
            background: rgba(122, 162, 255, .10)
        }

        .sw {
            width: 22px;
            height: 22px;
            border-radius: 7px;
            border: 1px solid rgba(255, 255, 255, .12);
            flex: 0 0 auto
        }

        .ciLeft {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 0
        }

        .ciText {
            display: flex;
            flex-direction: column;
            min-width: 0
        }

        .ciText b {
            font-size: 13px;
            line-height: 1.1
        }

        .ciText small {
            font-size: 12px;
            color: var(--muted);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap
        }

        .ciRight {
            font-variant-numeric: tabular-nums;
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap
        }

        /* åº•éƒ¨ç”»å¸ƒåŒº */
        .stage {
            display: flex;
            flex-direction: column;
            min-height: 0;
            flex: 1 1 auto;
            position: relative
        }

        .stageTop {
            padding: 12px 14px;
            border-bottom: 1px solid rgba(255, 255, 255, .08);
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap
        }

        .stageTop .meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            color: var(--muted);
            font-size: 12px
        }

        .stageMain {
            position: relative;
            flex: 1;
            min-height: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, .02), rgba(0, 0, 0, .05))
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none
        }

        .pill {
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .10)
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .62);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 16px;
            z-index: 999
        }

        .modal {
            width: min(980px, 96vw);
            max-height: min(92vh, 900px);
            display: flex;
            flex-direction: column
        }

        .modalHead {
            padding: 12px 14px;
            border-bottom: 1px solid rgba(255, 255, 255, .08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px
        }

        .modalBody {
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0
        }

        .modalBody .hint {
            color: var(--muted);
            font-size: 12px;
            line-height: 1.5
        }

        .modalCanvasWrap {
            background: rgba(0, 0, 0, .22);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 14px;
            overflow: hidden;
            height: min(60vh, 560px)
        }

        #cropCanvas {
            width: 100%;
            height: 100%;
            touch-action: none
        }

        .modalFoot {
            padding: 12px 14px;
            border-top: 1px solid rgba(255, 255, 255, .08);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 11px;
            padding: 2px 6px;
            border: 1px solid rgba(255, 255, 255, .14);
            border-radius: 6px;
            color: #d7dcf0;
            background: rgba(255, 255, 255, .06)
        }

        /* ====== æ‚¬æµ®æŒ‰é’®ï¼ˆå¯æ”¶èµ·ï¼Œé»˜è®¤å±•å¼€ï¼‰ ====== */
        .fab {
            position: fixed;
            right: 12px;
            bottom: calc(12px + env(safe-area-inset-bottom));
            z-index: 60;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: none;
        }

        .fab * {
            pointer-events: auto;
        }

        .fabPanel {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
            transform-origin: bottom right;
            transition: transform .18s ease, opacity .18s ease;
        }

        .fab.collapsed .fabPanel {
            transform: translateY(10px) scale(.98);
            opacity: 0;
            pointer-events: none;
        }

        .fabMain {
            height: 52px;
            padding: 0 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .14);
            background: rgba(18, 20, 27, .92);
            color: var(--text);
            box-shadow: var(--shadow);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-weight: 800;
            letter-spacing: .2px;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .fabMain:active {
            transform: translateY(1px)
        }

        .fabBtn {
            height: 44px;
            padding: 0 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .14);
            background: rgba(12, 14, 20, .88);
            color: var(--text);
            box-shadow: 0 10px 24px rgba(0, 0, 0, .30);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-weight: 700;
            font-size: 13px;
            white-space: nowrap;
        }

        .fabBtn.primary {
            background: rgba(122, 162, 255, .18);
            border-color: rgba(122, 162, 255, .35)
        }

        .fabBtn.ok {
            background: rgba(66, 211, 146, .16);
            border-color: rgba(66, 211, 146, .30)
        }

        .fabBtn.danger {
            background: rgba(255, 93, 93, .14);
            border-color: rgba(255, 93, 93, .25)
        }

        /* å¯¼å‡ºåˆ—è¡¨é¡¹é‡Œçš„ checkbox */
        .checkRow {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .checkRow input[type="checkbox"] {
            width: 18px;
            height: 18px;
            flex: 0 0 auto;
        }
    
        /* âœ… æ‰¹é‡ç‚¹é€‰å®Œæˆï¼šåº•éƒ¨ç¡®è®¤æ¡ */
        .multiBar{
            position:fixed;
            left:50%;
            bottom:16px;
            transform:translateX(-50%);
            z-index:99;
            width:min(560px,92vw);
            display:flex;
            align-items:center;
            justify-content:space-between;
            gap:12px;
            padding:10px 12px;
            border-radius:14px;
            background:rgba(20,20,26,.92);
            border:1px solid rgba(255,255,255,.12);
            box-shadow:0 10px 30px rgba(0,0,0,.35);
            backdrop-filter:blur(10px);
        }
        #filterPill{ white-space:nowrap; }

</style>
</head>

<body>
    <div class="app">
        <aside class="side card">
            <div class="header">
                <div class="title">
                    <b>æ‹¼è±†é€æ ¼é«˜äº®åŠ©æ‰‹</b>
                    <small>å¯¼å…¥å›¾çº¸ â†’ é€‰é¢œè‰² â†’ ä¸‹ä¸€æ ¼/å®Œæˆï¼ˆä¸è·³è§†å›¾ï¼‰</small>
                </div>
                <div class="chip" id="paletteChip">Mard è‰²å·</div>
            </div>

            <div class="content">
                <div class="row">
                    <div style="flex:1">
                        <label>å¯¼å…¥å›¾çº¸å›¾ç‰‡ï¼ˆå…ˆè£å‰ªï¼‰</label>
                        <input id="imgFile" type="file" accept="image/*">
                    </div>
                </div>

                <!-- âœ… é€‰æ‹©è‰²å·è¡¨ï¼ˆæ¥è‡ª JSï¼‰ -->
                <div class="row">
                    <div style="flex:1">
                        <label>è‰²å·è¡¨ï¼ˆé»˜è®¤ mard220ï¼‰</label>
                        <select id="paletteSelect"></select>
                    </div>
                </div>

                <div class="row" style="align-items:flex-end; gap:10px">
                    <button class="btn small" id="filterBtn" type="button">è¯†åˆ«é¢œè‰²é™åˆ¶</button>
                    <div class="pill" id="filterPill" style="margin:0">å…¨éƒ¨</div>
                </div>

                <div class="row">
                    <div style="flex:1">
                        <label>æˆ–è€…ï¼šå¯¼å…¥ CSV è‰²å·å›¾çº¸ï¼ˆä¸é é¢œè‰²è¯†åˆ«ï¼‰</label>
                        <input id="csvFile" type="file" accept=".csv,text/csv,text/plain">
                    </div>
                </div>

                <div class="grid2">
                    <div>
                        <label>ç½‘æ ¼å®½ Wï¼ˆâ‰¤104ï¼‰</label>
                        <input id="gridW" type="number" min="1" max="104" value="52">
                    </div>
                    <div>
                        <label>ç½‘æ ¼é«˜ Hï¼ˆâ‰¤104ï¼‰</label>
                        <input id="gridH" type="number" min="1" max="104" value="52">
                    </div>
                </div>

                <div class="toggle">
                    <input id="autoFit" type="checkbox" checked>
                    <div style="display:flex; flex-direction:column; gap:2px">
                        <b style="font-size:13px">è‡ªåŠ¨æŒ‰å›¾ç‰‡æ¯”ä¾‹é€‚é…</b>
                        <span style="font-size:12px; color:var(--muted)">å¯ç”¨æ—¶ä»¥ 104 ä¸ºæœ€å¤§è¾¹ï¼Œè‡ªåŠ¨ç®—
                            W/H</span>
                    </div>
                </div>

                <div class="grid2">
                    <div>
                        <label>æœ€å¤§ä½¿ç”¨é¢œè‰²æ•° Nï¼ˆå›¾ç‰‡å¯¼å…¥æ—¶ç”Ÿæ•ˆï¼‰</label>
                        <input id="maxColors" type="number" min="1" max="256" value="80">
                    </div>
                    <div>
                        <label>å¯¼å…¥è‰²å·é™åˆ¶è¡¨ sehao.csvï¼ˆå¯é€‰ï¼‰</label>
                        <input id="allowedFile" type="file" accept=".csv,text/csv,text/plain">
                    </div>
                </div>

                <div class="toggle">
                    <input id="limitSehao" type="checkbox" checked>
                    <div style="display:flex; flex-direction:column; gap:2px">
                        <b style="font-size:13px">ä½¿ç”¨ sehao.csv è‰²å·é™åˆ¶</b>
                        <span style="font-size:12px; color:var(--muted)">é¿å…ç”Ÿæˆä¸åœ¨æ¸…å•ä¸­çš„è‰²å·</span>
                    </div>
                </div>

                <div class="grid2">
                    <button class="btn small" id="fitBtn" type="button">é€‚é…å±å¹•</button>
                    <button class="btn small" id="resetViewBtn" type="button">é‡ç½®è§†å›¾</button>
                </div>

                <div class="grid2">
                    <button class="btn small" id="zoomOutBtn" type="button">ç¼©å°</button>
                    <button class="btn small" id="zoomInBtn" type="button">æ”¾å¤§</button>
                </div>

                <div class="grid2">
                    <button class="btn small" id="exportBtn" type="button">å¯¼å‡º</button>
                    <button class="btn small" id="bulkBtn" type="button">ä¸€é”®å®Œæˆè‰²å·</button>
                </div>

                <div class="toggle">
                    <input id="showCode" type="checkbox" checked>
                    <div style="display:flex; flex-direction:column; gap:2px">
                        <b style="font-size:13px">æ ¼å­å†…æ˜¾ç¤ºè‰²å·</b>
                        <span style="font-size:12px; color:var(--muted)">ç¼©æ”¾è¾ƒå°æ—¶ä¼šè‡ªåŠ¨ä¸ç”»å­—</span>
                    </div>
                </div>

                <!-- âœ… â€œåªçœ‹å½“å‰é¢œè‰²â€ å·²ç§»åˆ°æ‚¬æµ®æŒ‰é’®é‡Œï¼ˆè¿™é‡Œä¸å†æ”¾å¼€å…³ï¼‰ -->

                <div class="hr"></div>

                <div class="grid2">
                    <button class="btn primary wide" id="nextBtn" type="button">ä¸‹ä¸€æ ¼</button>
                    <button class="btn ok wide" id="doneBtn" type="button">å®Œæˆæ­¤æ ¼</button>
                </div>

                <div class="grid2">
                    <button class="btn wide" id="prevBtn" type="button">ä¸Šä¸€æ ¼</button>
                    <button class="btn danger wide" id="undoBtn" type="button">æ’¤é”€å®Œæˆ</button>
                </div>

                <div class="row" style="justify-content:space-between">
                    <span class="pill" id="statusPill">æœªå¯¼å…¥</span>
                    <span class="pill" id="posPill">â€”</span>
                </div>

                <div class="colors">
                    <div class="colorsTop">
                        <input id="colorSearch" type="text" placeholder="æœç´¢è‰²å·ï¼ˆä¾‹å¦‚ A1 / C20 / M15ï¼‰">
                        <button class="btn small" id="editCellBtn" type="button"
                            title="ç‚¹é€‰ä¸€ä¸ªæ ¼å­åå¯æ‰‹åŠ¨æ”¹è‰²">æ”¹è‰²</button>
                    </div>
                    <div class="list" id="colorList"></div>
                </div>
            </div>
        </aside>

        <main class="stage card">
            <div class="stageTop">
                <div class="meta">
                    <span>æ“ä½œï¼š</span>
                    <span class="pill">æ‹–æ‹½å¹³ç§»</span>
                    <span class="pill">æ»šè½®/åŒæŒ‡ç¼©æ”¾</span>
                    <span class="pill">ç‚¹æ ¼å­ï¼šå®šä½</span>
                </div>
                <div class="meta">
                    <span id="metaGrid">ç½‘æ ¼ï¼šâ€”</span>
                    <span id="metaColor">å½“å‰è‰²ï¼šâ€”</span>
                    <span id="metaTodo">å‰©ä½™ï¼šâ€”</span>
                </div>
            </div>
            <div class="stageMain">
                <canvas id="view"></canvas>
            </div>
        </main>
    </div>

    <!-- æ‚¬æµ®æ“ä½œï¼ˆé»˜è®¤å±•å¼€ï¼Œå¯æ”¶èµ·ï¼‰ -->
    <div class="fab" id="fab">
        <div class="fabPanel" id="fabPanel">
            <button class="fabBtn" id="fabPanelToggle" type="button">ğŸ§¾ éšè—é¢æ¿</button>
            <button class="fabBtn" id="fabOnly" type="button">ğŸ‘ï¸ åªçœ‹å½“å‰è‰²ï¼šå…³</button>
            <button class="fabBtn" id="fabCenter" type="button">ğŸ¯ å½“å‰æ ¼å±…ä¸­</button>

            <button class="fabBtn primary" id="fabPick" type="button">ğŸ¨ é€‰é¢œè‰²</button>
            <button class="fabBtn" id="fabFit" type="button">ğŸ§² é€‚é…</button>
            <button class="fabBtn" id="fabPrev" type="button">â¬…ï¸ ä¸Šä¸€æ ¼</button>
            <button class="fabBtn primary" id="fabNext" type="button">â¡ï¸ ä¸‹ä¸€æ ¼</button>
            <button class="fabBtn ok" id="fabDone" type="button">âœ… å®Œæˆæ­¤æ ¼</button>
            <button class="fabBtn ok" id="fabMulti" type="button">ğŸ§© æ‰¹é‡ç‚¹é€‰å®Œæˆ</button>
            <button class="fabBtn danger" id="fabUndo" type="button">â†©ï¸ æ’¤é”€</button>
            <button class="fabBtn ok" id="fabBulk" type="button">âš¡ ä¸€é”®å®Œæˆè‰²å·</button>
            <button class="fabBtn" id="fabExport" type="button">ğŸ“¦ å¯¼å‡º</button>
        </div>
        <button class="fabMain" id="fabMain" type="button">â‰¡ æ“ä½œé¢æ¿</button>
    </div>


    <!-- æ‰¹é‡ç‚¹é€‰å®Œæˆï¼šåº•éƒ¨ç¡®è®¤æ¡ï¼ˆä»…åœ¨â€œæ‰¹é‡æ¨¡å¼â€æ˜¾ç¤ºï¼‰ -->
    <div class="multiBar" id="multiBar" style="display:none">
        <div class="multiText">å·²é€‰ <b id="multiCount">0</b> æ ¼</div>
        <div style="display:flex; gap:8px">
            <button class="btn small ok" id="multiConfirm" type="button">æ ‡è®°å®Œæˆ</button>
            <button class="btn small" id="multiCancel" type="button">é€€å‡º</button>
        </div>
    </div>

    <!-- è£å‰ª -->
    <div class="overlay" id="cropOverlay">
        <div class="modal card">
            <div class="modalHead">
                <div class="title">
                    <b>è£å‰ªå›¾çº¸</b>
                    <small>æ‹–åŠ¨/ç¼©æ”¾è£å‰ªæ¡† â†’ åº”ç”¨è£å‰ªï¼ˆä¹Ÿå¯è·³è¿‡ï¼‰</small>
                </div>
                <button class="btn small" id="cropClose" type="button">å…³é—­</button>
            </div>
            <div class="modalBody">
                <div class="hint">æç¤ºï¼šè£å‰ªæ¡†å¯æ‹–åŠ¨ï¼›å››è§’å¯ç¼©æ”¾ã€‚ç§»åŠ¨ç«¯ç›´æ¥æ‰‹æŒ‡æ“ä½œå³å¯ã€‚</div>
                <div class="modalCanvasWrap"><canvas id="cropCanvas"></canvas></div>
                <div class="hint">å¿«æ·é”®ï¼ˆç”µè„‘ï¼‰ï¼š<span class="kbd">Esc</span> å…³é—­</div>
            </div>
            <div class="modalFoot">
                <button class="btn" id="cropSkip" type="button">è·³è¿‡è£å‰ª</button>
                <button class="btn primary" id="cropApply" type="button">åº”ç”¨è£å‰ª</button>
            </div>
        </div>
    </div>

    <!-- é€‰é¢œè‰² -->
    <div class="overlay" id="pickOverlay">
        <div class="modal card" style="width:min(720px,96vw)">
            <div class="modalHead">
                <div class="title">
                    <b>é€‰æ‹©å½“å‰é¢œè‰²</b>
                    <small>ç‚¹é€‰ä¸€ä¸ªè‰²å·å³å¯</small>
                </div>
                <button class="btn small" id="pickClose" type="button">å…³é—­</button>
            </div>
            <div class="modalBody" style="min-height:0">
                <input id="pickSearch" type="text" placeholder="æœç´¢è‰²å·ï¼ˆA1 / C20 / M15ï¼‰">
                <div class="list" id="pickList" style="max-height:60vh"></div>
            </div>
        </div>
    </div>

    <!-- æ‰‹åŠ¨æ”¹è‰² -->
    <div class="overlay" id="editOverlay">
        <div class="modal card" style="width:min(720px,96vw)">
            <div class="modalHead">
                <div class="title">
                    <b>æ‰‹åŠ¨æ”¹è‰²</b>
                    <small id="editInfo">â€”</small>
                </div>
                <button class="btn small" id="editClose" type="button">å…³é—­</button>
            </div>
            <div class="modalBody">
                <div class="hint">ç”¨äºä¿®æ­£â€œé¢œè‰²è¯†åˆ«â€è¯¯åˆ¤ï¼šå…ˆç‚¹é€‰ä¸€ä¸ªæ ¼å­ï¼Œå†åœ¨è¿™é‡Œé€‰æ­£ç¡®è‰²å·ã€‚</div>
                <input id="editSearch" type="text" placeholder="æœç´¢è‰²å·ï¼ˆä¾‹å¦‚ A1ï¼‰">
                <div class="list" id="editList" style="max-height:55vh"></div>
            </div>
        </div>
    </div>

    <!-- ä¸€é”®å®ŒæˆæŒ‡å®šè‰²å· -->
    <div class="overlay" id="bulkOverlay">
        <div class="modal card" style="width:min(720px,96vw)">
            <div class="modalHead">
                <div class="title">
                    <b>ä¸€é”®å®ŒæˆæŸä¸ªè‰²å·</b>
                    <small>é€‰æ‹©åï¼šè¯¥è‰²æ‰€æœ‰æœªå®Œæˆæ ¼å­éƒ½ä¼šæ ‡è®°å®Œæˆ</small>
                </div>
                <button class="btn small" id="bulkClose" type="button">å…³é—­</button>
            </div>
            <div class="modalBody" style="min-height:0">
                <input id="bulkSearch" type="text" placeholder="æœç´¢è‰²å·ï¼ˆA1 / C20 / M15ï¼‰">
                <div class="list" id="bulkList" style="max-height:60vh"></div>
                <div class="hint">æç¤ºï¼šå¯ç”¨â€œæ’¤é”€å®Œæˆâ€é€é¢—æ’¤é”€ï¼ˆæ‰¹é‡ä¼šåŠ å…¥å®Œæˆè®°å½•æ ˆï¼‰ã€‚</div>
            </div>
        </div>
    </div>

    
    <!-- è¯†åˆ«é¢œè‰²é™åˆ¶ï¼ˆæŒ‰ series / æŒ‰è‰²å·ï¼‰ -->
    <div class="overlay" id="filterOverlay">
        <div class="modal card" style="width:min(860px,96vw)">
            <div class="modalHead">
                <div class="title">
                    <b>è¯†åˆ«é¢œè‰²é™åˆ¶</b>
                    <small>é™åˆ¶è¯†åˆ«æ—¶å…è®¸åŒ¹é…çš„è‰²å·ï¼ˆä¼šä¸ sehao.csv é™åˆ¶å–äº¤é›†ï¼‰</small>
                </div>
                <button class="btn small" id="filterClose" type="button">å…³é—­</button>
            </div>

            <div class="modalBody" style="min-height:0">
                <div class="grid2" style="margin-bottom:10px">
                    <div>
                        <label>é™åˆ¶æ¨¡å¼</label>
                        <div style="display:flex; flex-wrap:wrap; gap:10px; margin-top:6px">
                            <label style="display:flex; align-items:center; gap:6px; font-size:13px">
                                <input type="radio" name="filterMode" id="filterModeNone" checked> ä¸é™åˆ¶
                            </label>
                            <label style="display:flex; align-items:center; gap:6px; font-size:13px">
                                <input type="radio" name="filterMode" id="filterModeSeries"> æŒ‰ç³»åˆ—ï¼ˆseriesï¼‰
                            </label>
                            <label style="display:flex; align-items:center; gap:6px; font-size:13px">
                                <input type="radio" name="filterMode" id="filterModeName"> æŒ‰è‰²å·ï¼ˆnameï¼‰
                            </label>
                        </div>
                    </div>
                    <div>
                        <label>å½“å‰è‰²å·è¡¨</label>
                        <div class="hint" id="filterPaletteHint" style="margin-top:8px">-</div>
                    </div>
                </div>

                <div id="filterBySeries" class="card" style="padding:12px; margin:10px 0">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px">
                        <b style="font-size:14px">é€‰æ‹©ç³»åˆ—ï¼ˆseriesï¼‰</b>
                        <div style="display:flex; gap:8px">
                            <button class="btn small" id="filterSeriesAll" type="button">å…¨é€‰</button>
                            <button class="btn small" id="filterSeriesNone" type="button">å…¨ä¸é€‰</button>
                        </div>
                    </div>
                    <div class="list" id="filterSeriesList" style="max-height:32vh; margin-top:10px"></div>
                </div>

                <div id="filterByName" class="card" style="padding:12px; margin:10px 0">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px">
                        <b style="font-size:14px">é€‰æ‹©è‰²å·ï¼ˆnameï¼‰</b>
                        <div style="display:flex; gap:8px">
                            <button class="btn small" id="filterNameAll" type="button">å…¨é€‰</button>
                            <button class="btn small" id="filterNameNone" type="button">å…¨ä¸é€‰</button>
                        </div>
                    </div>
                    <input id="filterNameSearch" type="text" placeholder="æœç´¢è‰²å·ï¼ˆA1 / C20 / M15ï¼‰" style="margin-top:10px">
                    <div class="list" id="filterNameList" style="max-height:32vh; margin-top:10px"></div>
                </div>

                <div class="hint">æç¤ºï¼šä¿®æ”¹é™åˆ¶åä¼šè‡ªåŠ¨é‡æ–°è¯†åˆ«ï¼ˆä½¿ç”¨åŒä¸€å¼ è£å‰ªåçš„å›¾ç‰‡ï¼‰ã€‚</div>
            </div>

            <div class="modalFoot">
                <button class="btn" id="filterClear" type="button">æ¸…ç©ºé™åˆ¶</button>
                <button class="btn primary" id="filterApply" type="button">åº”ç”¨é™åˆ¶</button>
            </div>
        </div>
    </div>


    <!-- å¯¼å‡º -->
    <div class="overlay" id="exportOverlay">
        <div class="modal card" style="width:min(860px,96vw)">
            <div class="modalHead">
                <div class="title">
                    <b>å¯¼å‡º</b>
                    <small>å¯¼å‡ºå›¾çº¸ / è‰²å·ç»Ÿè®¡ / PNG / JSONï¼Œå¹¶å¯å‹¾é€‰â€œä¸å¯¼å‡ºæŸäº›è‰²å·â€</small>
                </div>
                <button class="btn small" id="exportClose" type="button">å…³é—­</button>
            </div>

            <div class="modalBody" style="min-height:0">
                <div class="grid2">
                    <div>
                        <label>æœç´¢è‰²å·ï¼ˆå‹¾é€‰åˆ—è¡¨ç”¨ï¼‰</label>
                        <input id="exportSearch" type="text" placeholder="ä¾‹å¦‚ A1 / C20 / M15">
                    </div>
                    <div>
                        <label>PNG å¯¼å‡ºæ¨¡å¼</label>
                        <select id="exportPngMode">
                            <option value="grid_only">ä»…æ ¼å­ç”»</option>
                            <option value="grid_codes_legend">æ ¼å­ + è‰²å·æ ‡æ³¨ + ä¸‹æ–¹ç»Ÿè®¡</option>
                        </select>
                    </div>
                    <div class="toggle" style="margin:0">
                        <input id="exportBlankExcluded" type="checkbox" checked>
                        <div style="display:flex; flex-direction:column; gap:2px">
                            <b style="font-size:13px">å›¾çº¸é‡Œå°†æœªå¯¼å‡ºçš„è‰²å·ç•™ç©º</b>
                            <span
                                style="font-size:12px; color:var(--muted)">ä¸å‹¾é€‰åˆ™å›¾çº¸ä»ä¿ç•™è¿™äº›è‰²å·ï¼Œä»…ç»Ÿè®¡ä¸å¯¼å‡º</span>
                        </div>
                    </div>
                </div>

                <div class="grid2">
                    <button class="btn small" id="exportSelectAll" type="button">å…¨é€‰</button>
                    <button class="btn small" id="exportSelectNone" type="button">å…¨ä¸é€‰</button>
                </div>

                <div class="hint">å‹¾é€‰ = å…è®¸å¯¼å‡ºï¼›ä¸å‹¾é€‰ = ä¸å¯¼å‡ºè¯¥è‰²å·ï¼ˆç»Ÿè®¡/å›¾çº¸/PNG/JSONéƒ½ä¼šæŒ‰æ­¤è®¾ç½®å¤„ç†ï¼‰ã€‚</div>

                <div class="list" id="exportList" style="max-height:36vh"></div>
            </div>

            <div class="modalFoot">
                <button class="btn" id="exportGridCSV" type="button">å¯¼å‡ºå›¾çº¸ CSV</button>
                <button class="btn" id="exportStatsCSV" type="button">å¯¼å‡ºç»Ÿè®¡ CSV</button>
                <button class="btn" id="exportJSON" type="button">å¯¼å‡º JSON</button>
                <button class="btn primary" id="exportPNG" type="button">å¯¼å‡º PNG</button>
            </div>
        </div>
    </div>

    
    <!-- è‰²å·è¡¨ï¼ˆæ¥è‡ªç‹¬ç«‹ JS æ–‡ä»¶ï¼‰ -->
    <script src="mard_colors.js"></script>

<script>
        /**********************
         * 0) å¸¸é‡ï¼šç½‘æ ¼æœ€å¤§ 104
         **********************/
        const MAX_GRID = 104;

        /**********************
         * 1) ä½ çš„ mard è‰²å·è¡¨ï¼šname -> hex
         **********************/
                /**********************
         * 1) è‰²å·è¡¨ï¼šæ¥è‡ª mard_colors.js
         *    window.allColor: Map<paletteKey, Array<{color,name,series,transparency}>>
         **********************/
        const ALL_COLOR = (window.allColor instanceof Map) ? window.allColor : new Map();
        function getPaletteKeys() { return Array.from(ALL_COLOR.keys()); }
        function getPaletteRaw(key) { return ALL_COLOR.get(key) || []; }

        function normalizePalette(arr) {
            return (arr || []).map(p => ({
                name: String(p.name || '').trim().toUpperCase(),
                color: String(p.color || '').trim().replace(/^#/, '').toLowerCase(),
                series: String(p.series || '').trim().toUpperCase(),
                transparency: String(p.transparency || '').trim().toUpperCase(),
            })).filter(p => p.name && /^[0-9a-f]{6}$/.test(p.color));
        }

                // é»˜è®¤ä½¿ç”¨ mard220ï¼ˆå¦‚ä¸å­˜åœ¨åˆ™å–ç¬¬ä¸€ä¸ªï¼‰
        function pickDefaultPaletteKey() {
            const saved = localStorage.getItem('palette_key');
            if (saved && ALL_COLOR.has(saved)) return saved;
            if (ALL_COLOR.has('mard220')) return 'mard220';
            const keys = getPaletteKeys();
            return keys[0] || 'mard220';
        }
        function getPaletteListByKey(key) { return normalizePalette(getPaletteRaw(key)); }
        const DEFAULT_PALETTE_KEY = pickDefaultPaletteKey();

/**********************
         * State
         **********************/
        const state = {
            gridW: 0,
            gridH: 0,
            cells: null,
            usedColors: [],
            usedCounts: new Map(),
            codeToHex: new Map(),
            activeCode: null,
            activeTarget: null,
            history: [],
            done: new Set(),
            doneHistory: [],
            lastPickedCell: null,

            // âœ… å½“å‰è‰²å·è¡¨ï¼ˆmard220 / mard249 ...ï¼‰
            paletteKey: DEFAULT_PALETTE_KEY,
            paletteList: getPaletteListByKey(DEFAULT_PALETTE_KEY),

            // âœ… è¯†åˆ«é™åˆ¶ï¼šnone | series | nameï¼ˆä¼šä¸ sehao.csv é™åˆ¶å–äº¤é›†ï¼‰
            filterMode: (localStorage.getItem('filter_mode') || 'none'),
            filterSeries: new Set(JSON.parse(localStorage.getItem('filter_series') || '[]').map(s => String(s).toUpperCase())),
            filterNames: new Set(JSON.parse(localStorage.getItem('filter_names') || '[]').map(s => String(s).toUpperCase())),

            // âœ… æ‰¹é‡ç‚¹é€‰å®Œæˆ
            multiSelectMode: false,
            multiSelected: new Set(),

            // âœ… ä¿å­˜æœ€åä¸€æ¬¡è£å‰ªåçš„å›¾ç‰‡ï¼ˆæ–¹ä¾¿åˆ‡æ¢è‰²å·è¡¨/é™åˆ¶åè‡ªåŠ¨é‡æ–°è¯†åˆ«ï¼‰
            lastImageDataURL: null,


            // âœ… â€œåªçœ‹å½“å‰è‰²â€ æ”¹ä¸ºæ‚¬æµ®æŒ‰é’®æ§åˆ¶ + è®°å¿†
            onlyActiveColor: (localStorage.getItem('only_active_color') === '1'),

            showCode: true,
            allowedSet: null,
            allowedList: null,
            isReady: false,
        };

        const view = { zoom: 1, panX: 0, panY: 0, baseCell: 18 };

        /**********************
         * Elements
         **********************/
        const el = {
            imgFile: document.getElementById('imgFile'),
            csvFile: document.getElementById('csvFile'),
            allowedFile: document.getElementById('allowedFile'),
            gridW: document.getElementById('gridW'),
            gridH: document.getElementById('gridH'),
            autoFit: document.getElementById('autoFit'),
            limitSehao: document.getElementById('limitSehao'),
            maxColors: document.getElementById('maxColors'),

            // âœ… è‰²å·è¡¨é€‰æ‹© / è¯†åˆ«é™åˆ¶
            paletteSelect: document.getElementById('paletteSelect'),
            paletteChip: document.getElementById('paletteChip'),
            filterBtn: document.getElementById('filterBtn'),
            filterPill: document.getElementById('filterPill'),
            filterOverlay: document.getElementById('filterOverlay'),
            filterClose: document.getElementById('filterClose'),
            filterApply: document.getElementById('filterApply'),
            filterClear: document.getElementById('filterClear'),
            filterPaletteHint: document.getElementById('filterPaletteHint'),
            filterModeNone: document.getElementById('filterModeNone'),
            filterModeSeries: document.getElementById('filterModeSeries'),
            filterModeName: document.getElementById('filterModeName'),
            filterBySeries: document.getElementById('filterBySeries'),
            filterByName: document.getElementById('filterByName'),
            filterSeriesList: document.getElementById('filterSeriesList'),
            filterSeriesAll: document.getElementById('filterSeriesAll'),
            filterSeriesNone: document.getElementById('filterSeriesNone'),
            filterNameSearch: document.getElementById('filterNameSearch'),
            filterNameList: document.getElementById('filterNameList'),
            filterNameAll: document.getElementById('filterNameAll'),
            filterNameNone: document.getElementById('filterNameNone'),

            // âœ… PNG å¯¼å‡ºæ¨¡å¼
            exportPngMode: document.getElementById('exportPngMode'),


            fitBtn: document.getElementById('fitBtn'),
            resetViewBtn: document.getElementById('resetViewBtn'),
            zoomInBtn: document.getElementById('zoomInBtn'),
            zoomOutBtn: document.getElementById('zoomOutBtn'),
            exportBtn: document.getElementById('exportBtn'),
            bulkBtn: document.getElementById('bulkBtn'),

            showCode: document.getElementById('showCode'),

            nextBtn: document.getElementById('nextBtn'),
            prevBtn: document.getElementById('prevBtn'),
            doneBtn: document.getElementById('doneBtn'),
            undoBtn: document.getElementById('undoBtn'),

            statusPill: document.getElementById('statusPill'),
            posPill: document.getElementById('posPill'),

            colorSearch: document.getElementById('colorSearch'),
            colorList: document.getElementById('colorList'),

            metaGrid: document.getElementById('metaGrid'),
            metaColor: document.getElementById('metaColor'),
            metaTodo: document.getElementById('metaTodo'),

            view: document.getElementById('view'),
            editCellBtn: document.getElementById('editCellBtn'),

            // crop
            cropOverlay: document.getElementById('cropOverlay'),
            cropCanvas: document.getElementById('cropCanvas'),
            cropClose: document.getElementById('cropClose'),
            cropSkip: document.getElementById('cropSkip'),
            cropApply: document.getElementById('cropApply'),

            // pick
            pickOverlay: document.getElementById('pickOverlay'),
            pickClose: document.getElementById('pickClose'),
            pickSearch: document.getElementById('pickSearch'),
            pickList: document.getElementById('pickList'),

            // edit
            editOverlay: document.getElementById('editOverlay'),
            editClose: document.getElementById('editClose'),
            editSearch: document.getElementById('editSearch'),
            editList: document.getElementById('editList'),
            editInfo: document.getElementById('editInfo'),

            // bulk
            bulkOverlay: document.getElementById('bulkOverlay'),
            bulkClose: document.getElementById('bulkClose'),
            bulkSearch: document.getElementById('bulkSearch'),
            bulkList: document.getElementById('bulkList'),

            // export
            exportOverlay: document.getElementById('exportOverlay'),
            exportClose: document.getElementById('exportClose'),
            exportSearch: document.getElementById('exportSearch'),
            exportList: document.getElementById('exportList'),
            exportBlankExcluded: document.getElementById('exportBlankExcluded'),
            exportSelectAll: document.getElementById('exportSelectAll'),
            exportSelectNone: document.getElementById('exportSelectNone'),
            exportGridCSV: document.getElementById('exportGridCSV'),
            exportStatsCSV: document.getElementById('exportStatsCSV'),
            exportJSON: document.getElementById('exportJSON'),
            exportPNG: document.getElementById('exportPNG'),

            // fab
            fab: document.getElementById('fab'),
            fabMain: document.getElementById('fabMain'),
            fabPick: document.getElementById('fabPick'),
            fabFit: document.getElementById('fabFit'),
            fabPrev: document.getElementById('fabPrev'),
            fabNext: document.getElementById('fabNext'),
            fabDone: document.getElementById('fabDone'),
            fabMulti: document.getElementById('fabMulti'),
            fabUndo: document.getElementById('fabUndo'),
            fabBulk: document.getElementById('fabBulk'),
            fabExport: document.getElementById('fabExport'),

            // âœ… new fab buttons
            fabOnly: document.getElementById('fabOnly'),
            fabCenter: document.getElementById('fabCenter'),
            fabPanelToggle: document.getElementById('fabPanelToggle'),

            // âœ… æ‰¹é‡ç‚¹é€‰å®Œæˆï¼šåº•éƒ¨ç¡®è®¤æ¡
            multiBar: document.getElementById('multiBar'),
            multiCount: document.getElementById('multiCount'),
            multiConfirm: document.getElementById('multiConfirm'),
            multiCancel: document.getElementById('multiCancel'),
        };

        /**********************
         * Utils
         **********************/
        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)) }
        function hexToRgb(hex) {
            const m = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : { r: 0, g: 0, b: 0 };
        }
        function srgbToLinear(u) { u /= 255; return u <= 0.04045 ? u / 12.92 : Math.pow((u + 0.055) / 1.055, 2.4) }
        function rgbToLab(r, g, b) {
            const R = srgbToLinear(r), G = srgbToLinear(g), B = srgbToLinear(b);
            let x = (R * 0.4124564 + G * 0.3575761 + B * 0.1804375) / 0.95047;
            let y = (R * 0.2126729 + G * 0.7151522 + B * 0.0721750) / 1.00000;
            let z = (R * 0.0193339 + G * 0.1191920 + B * 0.9503041) / 1.08883;
            const f = t => t > 0.008856 ? Math.cbrt(t) : (7.787 * t + 16 / 116);
            const fx = f(x), fy = f(y), fz = f(z);
            return { L: 116 * fy - 16, a: 500 * (fx - fy), b: 200 * (fy - fz) };
        }
        function deltaE76(l1, l2) {
            const dL = l1.L - l2.L, da = l1.a - l2.a, db = l1.b - l2.b;
            return dL * dL + da * da + db * db;
        }
        function openOverlay(node) { node.style.display = 'flex' }
        function closeOverlay(node) { node.style.display = 'none' }

        function timeStamp() {
            const d = new Date();
            const pad = n => String(n).padStart(2, '0');
            return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
        }

        function downloadBlob(filename, blob) {
            const a = document.createElement('a');
            const url = URL.createObjectURL(blob);
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            // é‡Šæ”¾ URLï¼Œé¿å…å†…å­˜å ç”¨
            setTimeout(() => URL.revokeObjectURL(url), 0);
        }

/**********************
         * âœ… Palette & Filters (mard_colors.js)
         **********************/
        function updatePaletteChip() {
            if (!el.paletteChip) return;
            const key = state.paletteKey || DEFAULT_PALETTE_KEY;
            const n = (state.paletteList || []).length;
            el.paletteChip.textContent = `${key}ï¼ˆ${n}è‰²ï¼‰`;
            if (el.filterPaletteHint) el.filterPaletteHint.textContent = `${key}ï¼ˆ${n}è‰²ï¼‰`;
        }

        function updateFilterPill() {
            if (!el.filterPill) return;

            const parts = [];
            const mode = state.filterMode || 'none';

            if (el.limitSehao && el.limitSehao.checked) parts.push('sehao.csv');

            if (mode === 'series' && (state.filterSeries?.size || 0) > 0) {
                parts.push(`ç³»åˆ—:${(state.filterSeries?.size || 0)}`);
            } else if (mode === 'name' && (state.filterNames?.size || 0) > 0) {
                parts.push(`è‰²å·:${(state.filterNames?.size || 0)}`);
            }

            el.filterPill.textContent = (parts.length === 0) ? 'å…¨éƒ¨' : parts.join(' + ');
        }

        function rerunFromLastImage(okText, fallbackText) {
            // okTextï¼šæœ‰ lastImageDataURL æ—¶æ˜¾ç¤ºï¼›fallbackTextï¼šæ²¡æœ‰ lastImageDataURL æ—¶æ˜¾ç¤º
            if (!state.lastImageDataURL) {
                el.statusPill.textContent = fallbackText || 'è¯·å…ˆå¯¼å…¥å¹¶è£å‰ªå›¾ç‰‡';
                return;
            }
            const img = new Image();
            img.onload = () => {
                try {
                    buildFromImage(img);
                    el.statusPill.textContent = okText || 'å·²é‡æ–°è¯†åˆ«';
                } catch (err) {
                    alert(err?.message || String(err));
                }
            };
            img.src = state.lastImageDataURL;
        }

        function initPaletteSelect() {
            if (!el.paletteSelect) return;
            const keys = getPaletteKeys();
            el.paletteSelect.innerHTML = '';
            for (const k of keys) {
                const opt = document.createElement('option');
                opt.value = k;
                opt.textContent = k;
                el.paletteSelect.appendChild(opt);
            }
            if (!keys.includes(state.paletteKey)) state.paletteKey = DEFAULT_PALETTE_KEY;
            el.paletteSelect.value = state.paletteKey;
            updatePaletteChip();
        }

        function setPaletteKey(key) {
            if (!key || !ALL_COLOR.has(key)) return;
            state.paletteKey = key;
            localStorage.setItem('palette_key', key);
            rebuildPaletteMaps();
            initFilterOverlayData();
            initPaletteSelect();
            rerunFromLastImage(`å·²åˆ‡æ¢è‰²å·è¡¨ä¸º ${key} å¹¶é‡æ–°è¯†åˆ«`, `å·²åˆ‡æ¢è‰²å·è¡¨ä¸º ${key}ï¼ˆè¯·é‡æ–°å¯¼å…¥/è£å‰ªåè¯†åˆ«ï¼‰`);
        }

        function setFilterMode(mode) {
            state.filterMode = mode;
            localStorage.setItem('filter_mode', mode);
        }
        function persistFilterSets() {
            localStorage.setItem('filter_series', JSON.stringify([...state.filterSeries]));
            localStorage.setItem('filter_names', JSON.stringify([...state.filterNames]));
        }

        function initFilterOverlayData() {
            // ç¡®ä¿å½“å‰ paletteList å·²æ›´æ–°
            state.paletteList = getPaletteListByKey(state.paletteKey);
            updatePaletteChip();
            updateFilterPill();
        }

        function refreshFilterOverlayUI() {
            if (!el.filterOverlay) return;

            initFilterOverlayData();

            // radio
            const mode = state.filterMode || 'none';
            if (el.filterModeNone) el.filterModeNone.checked = (mode === 'none');
            if (el.filterModeSeries) el.filterModeSeries.checked = (mode === 'series');
            if (el.filterModeName) el.filterModeName.checked = (mode === 'name');

            if (el.filterBySeries) el.filterBySeries.style.display = (mode === 'series') ? '' : 'none';
            if (el.filterByName) el.filterByName.style.display = (mode === 'name') ? '' : 'none';

            // series list
            if (el.filterSeriesList) {
                const series = [...new Set((state.paletteList || []).map(p => p.series).filter(Boolean))].sort();
                el.filterSeriesList.innerHTML = '';
                for (const s of series) {
                    const count = (state.paletteList || []).filter(p => p.series === s).length;
                    const item = document.createElement('div');
                    item.className = 'colorItem';
                    const checked = state.filterSeries.has(s);
                    item.innerHTML = `
          <div class="ciLeft">
            <label style="display:flex; align-items:center; gap:10px">
              <input type="checkbox" ${checked ? 'checked' : ''} data-series="${s}">
              <b>${s}</b>
              <small>${count}è‰²</small>
            </label>
          </div>
        `;
                    el.filterSeriesList.appendChild(item);
                }
            }

            // names list
            refreshFilterNameList();
        }

        function refreshFilterNameList() {
            if (!el.filterNameList) return;
            const q = (el.filterNameSearch?.value || '').trim().toUpperCase();

            const names = (state.paletteList || [])
                .map(p => p.name)
                .filter(Boolean)
                .filter(n => !q || n.includes(q))
                .sort((a, b) => a.localeCompare(b, 'en'));

            el.filterNameList.innerHTML = '';
            for (const name of names) {
                const item = document.createElement('div');
                item.className = 'colorItem';
                const hex = state.codeToHex.get(name) || '000000';
                const checked = state.filterNames.has(name);
                item.innerHTML = `
          <div class="ciLeft">
            <label style="display:flex; align-items:center; gap:10px">
              <input type="checkbox" ${checked ? 'checked' : ''} data-name="${name}">
              <div class="sw" style="background:#${hex}"></div>
              <b>${name}</b>
              <small>#${hex}</small>
            </label>
          </div>
        `;
                el.filterNameList.appendChild(item);
            }
        }

        function applyFilterFromOverlay() {
            // mode
            let mode = 'none';
            if (el.filterModeSeries?.checked) mode = 'series';
            if (el.filterModeName?.checked) mode = 'name';
            setFilterMode(mode);

            // series set
            if (mode === 'series') {
                const set = new Set();
                el.filterSeriesList?.querySelectorAll('input[type="checkbox"][data-series]').forEach(chk => {
                    if (chk.checked) set.add(String(chk.dataset.series || '').toUpperCase());
                });
                state.filterSeries = set;
            }

            // names set
            if (mode === 'name') {
                const set = new Set();
                el.filterNameList?.querySelectorAll('input[type="checkbox"][data-name]').forEach(chk => {
                    if (chk.checked) set.add(String(chk.dataset.name || '').toUpperCase());
                });
                state.filterNames = set;
            }

            persistFilterSets();
            rebuildPaletteMaps();
            closeOverlay(el.filterOverlay);
            rerunFromLastImage('å·²åº”ç”¨è¯†åˆ«é™åˆ¶å¹¶é‡æ–°è¯†åˆ«', 'å·²åº”ç”¨è¯†åˆ«é™åˆ¶ï¼ˆè¯·é‡æ–°å¯¼å…¥/è£å‰ªåè¯†åˆ«ï¼‰');
        }

        /**********************
         * âœ… Multi Select Done
         **********************/
        function updateMultiBar() {
            if (!el.multiBar) return;
            if (!state.multiSelectMode) { el.multiBar.style.display = 'none'; return; }
            el.multiBar.style.display = '';
            if (el.multiCount) el.multiCount.textContent = String(state.multiSelected.size || 0);
        }

        function enterMultiSelectMode() {
            if (!state.isReady) return;
            state.multiSelectMode = true;
            state.multiSelected.clear();
            updateMultiBar();
            el.statusPill.textContent = 'æ‰¹é‡ç‚¹é€‰å®Œæˆï¼šç‚¹å‡»æ ¼å­è¿›è¡Œé€‰æ‹©';
            requestDraw();
        }

        function exitMultiSelectMode() {
            state.multiSelectMode = false;
            state.multiSelected.clear();
            updateMultiBar();
            el.statusPill.textContent = 'å·²é€€å‡ºæ‰¹é‡ç‚¹é€‰';
            requestDraw();
        }

        function confirmMultiDone() {
            if (!state.isReady) return;
            if (state.multiSelected.size === 0) { el.statusPill.textContent = 'æœªé€‰æ‹©ä»»ä½•æ ¼å­'; return; }
            let added = 0;
            for (const k of state.multiSelected) {
                if (!state.done.has(k)) {
                    state.done.add(k);
                    state.doneHistory.push(k);
                    added++;
                }
            }
            if (state.doneHistory.length > 200000) state.doneHistory.splice(0, state.doneHistory.length - 200000);
            el.statusPill.textContent = `æ‰¹é‡å®Œæˆï¼šæ–°å¢ ${added} æ ¼`;
            exitMultiSelectMode();
            updateMeta();
            requestDraw();
        }

        function downloadText(filename, text, mime) {
            downloadBlob(filename, new Blob([text], { type: mime || 'text/plain;charset=utf-8' }));
        }

        /**********************
         * âœ… å¹³æ¿è¿ç‚¹æŒ‰é’®æ”¾å¤§ï¼šä»…å¯¹æŒ‰é’®é˜»æ­¢ double-tap zoom
         **********************/
        function installNoDoubleTapZoomForButtons() {
            const targets = document.querySelectorAll('button, .btn, .fabBtn, .fabMain');
            targets.forEach(t => {
                let last = 0;
                t.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - last <= 320) {
                        e.preventDefault();
                    }
                    last = now;
                }, { passive: false });
            });
        }

        /**********************
         * âœ… é¡¶éƒ¨åˆ†æ æ˜¾ç¤º/éšè—ï¼ˆè®°å¿†ï¼‰
         **********************/
        function setPanelHidden(hidden) {
            document.body.classList.toggle('panelHidden', !!hidden);
            localStorage.setItem('panel_hidden', hidden ? '1' : '0');
            updateFabPanelToggleText();

            // é¢æ¿é«˜åº¦å˜åŒ–ä¼šå½±å“ canvas å°ºå¯¸ï¼šé‡ç®—å¹¶å°½é‡é€‚é…
            setTimeout(() => {
                resizeViewCanvas();
                if (state.isReady) fitToScreen();
            }, 50);
        }
        function updateFabPanelToggleText() {
            const hidden = document.body.classList.contains('panelHidden');
            el.fabPanelToggle.textContent = hidden ? 'ğŸ§¾ æ˜¾ç¤ºé¢æ¿' : 'ğŸ§¾ éšè—é¢æ¿';
            el.fabPanelToggle.classList.toggle('primary', !hidden);
        }

        /**********************
         * âœ… â€œåªçœ‹å½“å‰è‰²â€ æ‚¬æµ®æŒ‰é’®
         **********************/
        function updateFabOnlyText() {
            const on = !!state.onlyActiveColor;
            el.fabOnly.textContent = on ? 'ğŸ‘ï¸ åªçœ‹å½“å‰è‰²ï¼šå¼€' : 'ğŸ‘ï¸ åªçœ‹å½“å‰è‰²ï¼šå…³';
            el.fabOnly.classList.toggle('primary', on);
        }
        function toggleOnlyActiveColor() {
            state.onlyActiveColor = !state.onlyActiveColor;
            localStorage.setItem('only_active_color', state.onlyActiveColor ? '1' : '0');
            updateFabOnlyText();
            requestDraw();
        }

        /**********************
         * âœ… å½“å‰é«˜äº®æ ¼å±…ä¸­
         **********************/
        function centerOnCurrentTarget() {
            if (!state.isReady) return alert('è¯·å…ˆå¯¼å…¥å›¾çº¸');
            const t = state.activeTarget || state.lastPickedCell;
            if (!t) return alert('è¿˜æ²¡æœ‰é€‰ä¸­/é«˜äº®ä»»ä½•æ ¼å­');
            const cw = el.view.width, ch = el.view.height;
            const z = view.zoom, cell = view.baseCell;

            const wx = (t.x + 0.5) * cell;
            const wy = (t.y + 0.5) * cell;

            view.panX = cw / 2 - wx * z;
            view.panY = ch / 2 - wy * z;
            requestDraw();
        }

        /**********************
         * Palette maps + allowed list
         **********************/
        function rebuildPaletteMaps() {
            // 1) ç¡®ä¿ paletteList åŒæ­¥
            if (!state.paletteKey) state.paletteKey = DEFAULT_PALETTE_KEY;
            state.paletteList = getPaletteListByKey(state.paletteKey);

            // 2) code -> hex
            state.codeToHex.clear();
            for (const p of state.paletteList) { state.codeToHex.set(p.name, p.color); }

            // 3) è®¡ç®—å…è®¸çš„è¯†åˆ«è‰²å·ï¼ˆä¸ sehao.csv / series / name é™åˆ¶å–äº¤é›†ï¼‰
            const baseSet = new Set(state.paletteList.map(p => p.name));

            const intersect = (A, B) => {
                const out = new Set();
                for (const v of A) { if (B.has(v)) out.add(v); }
                return out;
            };

            let allowed = null; // null ä»£è¡¨ä¸é™åˆ¶

            // 3.1 sehao.csv é™åˆ¶ï¼ˆå¯é€‰ï¼‰
            let hasSehao = false;
            if (el.limitSehao && el.limitSehao.checked) {
                hasSehao = true;
                const list = (state.allowedList && state.allowedList.length) ? state.allowedList : Array.from(baseSet);
                allowed = new Set(list.map(s => String(s).trim().toUpperCase()).filter(c => baseSet.has(c)));
            }

            // 3.2 series / name é™åˆ¶ï¼ˆç©ºé›†åˆè§†ä½œâ€œä¸é™åˆ¶â€ï¼‰
            const mode = (state.filterMode || 'none');

            let hasFilter = false;
            if (mode === 'series') {
                const seriesSet = state.filterSeries || new Set();
                if (seriesSet.size > 0) {
                    hasFilter = true;
                    const codesInSeries = new Set(state.paletteList.filter(p => seriesSet.has(p.series)).map(p => p.name));
                    allowed = allowed ? intersect(allowed, codesInSeries) : codesInSeries;
                }
            } else if (mode === 'name') {
                const nameSet = state.filterNames || new Set();
                if (nameSet.size > 0) {
                    hasFilter = true;
                    const valid = new Set([...nameSet].filter(n => baseSet.has(n)));
                    allowed = allowed ? intersect(allowed, valid) : valid;
                }
            }

            state.allowedSet = (hasSehao || hasFilter) ? allowed : null;

            // UI
            updatePaletteChip();
            updateFilterPill();
        }
        rebuildPaletteMaps();

        function parseAllowedCodesCSV(text) {
            const tokens = text.replace(/\r/g, '\n').split(/\n|,|;|\t|\s+/).map(s => s.trim()).filter(Boolean);
            const set = new Set();
            for (const t of tokens) {
                const code = t.toUpperCase();
                if (state.codeToHex.has(code)) set.add(code);
            }
            return [...set];
        }

        /**********************
         * CSV mode: parse code grid
         **********************/
        function parseCodeCSV(text) {
            const lines = text.replace(/\r/g, '\n').split('\n').map(s => s.trim()).filter(Boolean);
            const rows = lines.map(line => line.split(/[,;\t ]+/).map(x => x.trim()).filter(Boolean));
            const H = rows.length;
            const W = Math.max(...rows.map(r => r.length));
            if (W < 1 || H < 1) throw new Error('CSV ä¸ºç©ºæˆ–æ ¼å¼ä¸å¯¹');
            if (W > MAX_GRID || H > MAX_GRID) throw new Error(`CSV ç½‘æ ¼è¶…è¿‡ ${MAX_GRID}Ã—${MAX_GRID}`);
            for (const r of rows) { while (r.length < W) r.push(''); }
            return { W, H, rows };
        }

        function buildFromCSV(rows, W, H) {
            rebuildPaletteMaps();
            state.gridW = W; state.gridH = H;
            state.done.clear(); state.doneHistory.length = 0;
            state.history.length = 0; state.activeTarget = null;

            const codeCount = new Map();
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const code = (rows[y][x] || '').trim().toUpperCase();
                    if (!code) continue;
                    if (state.allowedSet && !state.allowedSet.has(code)) continue;
                    if (!state.codeToHex.has(code)) continue;
                    codeCount.set(code, (codeCount.get(code) || 0) + 1);
                }
            }
            const used = [...codeCount.entries()].sort((a, b) => b[1] - a[1]).map(([code, count]) => ({ code, hex: state.codeToHex.get(code), count }));
            state.usedColors = used.map(u => ({ code: u.code, hex: u.hex }));
            state.usedCounts = new Map(used.map(u => [u.code, u.count]));

            const idxMap = new Map();
            state.usedColors.forEach((u, i) => idxMap.set(u.code, i));
            state.cells = new Int16Array(W * H);
            state.cells.fill(-1);
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const code = (rows[y][x] || '').trim().toUpperCase();
                    if (!code) continue;
                    if (state.allowedSet && !state.allowedSet.has(code)) continue;
                    const idx = idxMap.get(code);
                    if (idx === undefined) continue;
                    state.cells[y * W + x] = idx;
                }
            }

            state.activeCode = state.usedColors[0]?.code || null;
            state.isReady = true;
            syncUIAfterBuild();
            fitToScreen();
        }

        /**********************
         * Crop (image import)
         **********************/
        const crop = {
            img: null,
            displayScale: 1,
            rect: { x: 0, y: 0, w: 0, h: 0 },
            dragging: false,
            dragMode: null,
            last: { x: 0, y: 0 },
            offsetX: 0, offsetY: 0,
        };

        function openCrop(img) {
            crop.img = img;
            openOverlay(el.cropOverlay);
            requestAnimationFrame(() => layoutCropCanvas(true));
        }

        function layoutCropCanvas(resetRect) {
            const c = el.cropCanvas;
            const wrap = c.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            c.width = Math.max(1, Math.floor(wrap.width * dpr));
            c.height = Math.max(1, Math.floor(wrap.height * dpr));

            const iw = crop.img.naturalWidth, ih = crop.img.naturalHeight;
            const sx = c.width / iw, sy = c.height / ih;
            crop.displayScale = Math.min(sx, sy);

            const dw = iw * crop.displayScale, dh = ih * crop.displayScale;
            crop.offsetX = (c.width - dw) / 2;
            crop.offsetY = (c.height - dh) / 2;

            if (resetRect) {
                crop.rect.x = crop.offsetX; crop.rect.y = crop.offsetY;
                crop.rect.w = dw; crop.rect.h = dh;
            } else {
                crop.rect.x = clamp(crop.rect.x, crop.offsetX, crop.offsetX + dw - 10);
                crop.rect.y = clamp(crop.rect.y, crop.offsetY, crop.offsetY + dh - 10);
                crop.rect.w = clamp(crop.rect.w, 10, crop.offsetX + dw - crop.rect.x);
                crop.rect.h = clamp(crop.rect.h, 10, crop.offsetY + dh - crop.rect.y);
            }
            drawCrop();
        }

        function drawCrop() {
            const c = el.cropCanvas;
            const ctx = c.getContext('2d');
            ctx.clearRect(0, 0, c.width, c.height);
            ctx.fillStyle = 'rgba(0,0,0,.25)';
            ctx.fillRect(0, 0, c.width, c.height);

            const iw = crop.img.naturalWidth, ih = crop.img.naturalHeight;
            const dw = iw * crop.displayScale, dh = ih * crop.displayScale;
            ctx.drawImage(crop.img, crop.offsetX, crop.offsetY, dw, dh);

            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,.45)';
            ctx.beginPath();
            ctx.rect(0, 0, c.width, c.height);
            ctx.rect(crop.rect.x, crop.rect.y, crop.rect.w, crop.rect.h);
            ctx.fill('evenodd');
            ctx.restore();

            ctx.save();
            ctx.strokeStyle = 'rgba(122,162,255,.95)';
            ctx.lineWidth = 3;
            ctx.strokeRect(crop.rect.x, crop.rect.y, crop.rect.w, crop.rect.h);

            const hs = 12;
            const pts = [
                { k: 'nw', x: crop.rect.x, y: crop.rect.y },
                { k: 'ne', x: crop.rect.x + crop.rect.w, y: crop.rect.y },
                { k: 'sw', x: crop.rect.x, y: crop.rect.y + crop.rect.h },
                { k: 'se', x: crop.rect.x + crop.rect.w, y: crop.rect.y + crop.rect.h },
            ];
            ctx.fillStyle = 'rgba(122,162,255,.95)';
            for (const p of pts) { ctx.beginPath(); ctx.arc(p.x, p.y, hs / 2, 0, Math.PI * 2); ctx.fill(); }
            ctx.restore();
        }

        function cropHitTest(x, y) {
            const hs = 14;
            const corners = [
                { k: 'nw', x: crop.rect.x, y: crop.rect.y },
                { k: 'ne', x: crop.rect.x + crop.rect.w, y: crop.rect.y },
                { k: 'sw', x: crop.rect.x, y: crop.rect.y + crop.rect.h },
                { k: 'se', x: crop.rect.x + crop.rect.w, y: crop.rect.y + crop.rect.h },
            ];
            for (const c of corners) {
                const dx = x - c.x, dy = y - c.y;
                if (dx * dx + dy * dy <= hs * hs) return c.k;
            }
            if (x >= crop.rect.x && x <= crop.rect.x + crop.rect.w && y >= crop.rect.y && y <= crop.rect.y + crop.rect.h) return 'move';
            return null;
        }

        function onCropPointerDown(e) {
            const c = el.cropCanvas;
            c.setPointerCapture(e.pointerId);
            const dpr = window.devicePixelRatio || 1;
            const rect = c.getBoundingClientRect();
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;
            const mode = cropHitTest(x, y);
            if (!mode) return;
            crop.dragging = true; crop.dragMode = mode;
            crop.last.x = x; crop.last.y = y;
        }
        function onCropPointerMove(e) {
            if (!crop.dragging) return;
            const c = el.cropCanvas;
            const dpr = window.devicePixelRatio || 1;
            const rect = c.getBoundingClientRect();
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;
            const dx = x - crop.last.x, dy = y - crop.last.y;
            crop.last.x = x; crop.last.y = y;

            const bounds = {
                x0: crop.offsetX,
                y0: crop.offsetY,
                x1: crop.offsetX + crop.img.naturalWidth * crop.displayScale,
                y1: crop.offsetY + crop.img.naturalHeight * crop.displayScale,
            };
            const minSize = 20;

            if (crop.dragMode === 'move') {
                crop.rect.x = clamp(crop.rect.x + dx, bounds.x0, bounds.x1 - crop.rect.w);
                crop.rect.y = clamp(crop.rect.y + dy, bounds.y0, bounds.y1 - crop.rect.h);
            } else {
                let x0 = crop.rect.x, y0 = crop.rect.y, x1 = crop.rect.x + crop.rect.w, y1 = crop.rect.y + crop.rect.h;
                if (crop.dragMode.includes('n')) y0 += dy;
                if (crop.dragMode.includes('w')) x0 += dx;
                if (crop.dragMode.includes('s')) y1 += dy;
                if (crop.dragMode.includes('e')) x1 += dx;

                x0 = clamp(x0, bounds.x0, x1 - minSize);
                y0 = clamp(y0, bounds.y0, y1 - minSize);
                x1 = clamp(x1, x0 + minSize, bounds.x1);
                y1 = clamp(y1, y0 + minSize, bounds.y1);

                crop.rect.x = x0; crop.rect.y = y0; crop.rect.w = x1 - x0; crop.rect.h = y1 - y0;
            }
            drawCrop();
        }
        function onCropPointerUp() { crop.dragging = false; crop.dragMode = null; }

        function applyCropToImage() {
            const sx = (crop.rect.x - crop.offsetX) / crop.displayScale;
            const sy = (crop.rect.y - crop.offsetY) / crop.displayScale;
            const sw = crop.rect.w / crop.displayScale;
            const sh = crop.rect.h / crop.displayScale;

            const out = document.createElement('canvas');
            out.width = Math.max(1, Math.floor(sw));
            out.height = Math.max(1, Math.floor(sh));
            const ctx = out.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(crop.img, sx, sy, sw, sh, 0, 0, out.width, out.height);

            const img = new Image();
            img.onload = () => { closeOverlay(el.cropOverlay); buildFromImage(img); };
            img.src = out.toDataURL('image/png');
            state.lastImageDataURL = img.src;
        }

        /**********************
         * Image mode (quantize to nearest Mard) + maxColors limit
         **********************/
        function applyMaxColorsLimit(W, H, cells, usedColors, counts, maxN) {
            if (!maxN || maxN < 1) return { cells, usedColors, counts };
            if (usedColors.length <= maxN) return { cells, usedColors, counts };

            const keep = usedColors.slice(0, maxN);
            const keepLabs = keep.map(u => {
                const rgb = hexToRgb(u.hex);
                return { code: u.code, hex: u.hex, lab: rgbToLab(rgb.r, rgb.g, rgb.b) };
            });

            const mapOldToNew = new Map();
            for (let i = 0; i < keep.length; i++) {
                const oldIdx = usedColors.findIndex(u => u.code === keep[i].code);
                mapOldToNew.set(oldIdx, i);
            }

            const excludedMap = new Map();
            for (let oldIdx = 0; oldIdx < usedColors.length; oldIdx++) {
                if (mapOldToNew.has(oldIdx)) continue;
                const u = usedColors[oldIdx];
                const rgb = hexToRgb(u.hex);
                const lab = rgbToLab(rgb.r, rgb.g, rgb.b);
                let best = 0, bestD = Infinity;
                for (let i = 0; i < keepLabs.length; i++) {
                    const d = deltaE76(lab, keepLabs[i].lab);
                    if (d < bestD) { bestD = d; best = i; }
                }
                excludedMap.set(oldIdx, best);
            }

            const newCells = new Int16Array(W * H);
            newCells.fill(-1);
            const newCounts = new Map();
            for (const u of keep) { newCounts.set(u.code, 0); }

            for (let i = 0; i < cells.length; i++) {
                const old = cells[i];
                if (old < 0) { newCells[i] = -1; continue; }
                let ni = mapOldToNew.get(old);
                if (ni === undefined) ni = excludedMap.get(old);
                newCells[i] = ni;
                const code = keep[ni].code;
                newCounts.set(code, (newCounts.get(code) || 0) + 1);
            }

            const sortedKeep = [...newCounts.entries()].sort((a, b) => b[1] - a[1]).map(([code, count]) => {
                const u = keep.find(x => x.code === code);
                return { code, hex: u.hex, count };
            });

            const resortMap = new Map();
            sortedKeep.forEach((u, i) => resortMap.set(u.code, i));
            const finalCells = new Int16Array(W * H);
            finalCells.fill(-1);
            const finalCounts = new Map();
            for (const u of sortedKeep) { finalCounts.set(u.code, u.count); }

            for (let i = 0; i < newCells.length; i++) {
                const ci = newCells[i];
                if (ci < 0) continue;
                const code = keep[ci].code;
                finalCells[i] = resortMap.get(code);
            }

            const finalUsed = sortedKeep.map(u => ({ code: u.code, hex: u.hex }));
            return { cells: finalCells, usedColors: finalUsed, counts: finalCounts };
        }

        function buildFromImage(img) {
            rebuildPaletteMaps();

            // å€™é€‰è‰²å¡ï¼ˆæ¥è‡ªå½“å‰ paletteKeyï¼‰
            let candidates = (state.paletteList || []).map(p => ({ name: p.name, color: p.color, series: p.series }));
            if (state.allowedSet) {
                candidates = candidates.filter(p => state.allowedSet.has(p.name));
            }
            const cand = candidates.map(p => {
                const rgb = hexToRgb(p.color);
                return { code: p.name, hex: p.color, lab: rgbToLab(rgb.r, rgb.g, rgb.b) };
            });
            if (cand.length === 0) throw new Error('å€™é€‰è‰²å¡ä¸ºç©ºï¼ˆæ£€æŸ¥ sehao / series / name é™åˆ¶ï¼‰');

            let W = parseInt(el.gridW.value, 10) || 52;
            let H = parseInt(el.gridH.value, 10) || 52;
            W = clamp(W, 1, MAX_GRID); H = clamp(H, 1, MAX_GRID);

            if (el.autoFit.checked) {
                const iw = img.naturalWidth, ih = img.naturalHeight;
                if (iw >= ih) {
                    H = clamp(Math.round(W * ih / iw), 1, MAX_GRID);
                } else {
                    W = clamp(Math.round(H * iw / ih), 1, MAX_GRID);
                }
                el.gridW.value = W; el.gridH.value = H;
            }

            // âœ… æ›´å‡†ç¡®çš„é‡‡æ ·ï¼šä¸æŠŠå›¾ç‰‡ç›´æ¥ç¼©æ”¾æˆ WÃ—Hï¼Œè€Œæ˜¯å¯¹æ¯ä¸ªæ ¼å­çš„â€œä¸­å¿ƒåŒºåŸŸâ€åšå¤šç‚¹é‡‡æ ·
            const iw = img.naturalWidth, ih = img.naturalHeight;
            const src = document.createElement('canvas');
            src.width = iw; src.height = ih;
            const sctx = src.getContext('2d', { willReadFrequently: true });
            sctx.imageSmoothingEnabled = false;
            sctx.drawImage(img, 0, 0);
            const data = sctx.getImageData(0, 0, iw, ih).data;

            const cache = new Map();
            function nearestCode(r, g, b) {
                const key = (r << 16) | (g << 8) | b;
                const hit = cache.get(key);
                if (hit) return hit;
                const lab = rgbToLab(r, g, b);
                let best = cand[0], bestD = Infinity;
                for (const c of cand) {
                    const d = deltaE76(lab, c.lab);
                    if (d < bestD) { bestD = d; best = c; }
                }
                cache.set(key, best);
                return best;
            }

            const codeGrid = new Array(W * H).fill('');
            const codeCount = new Map();

            // å¦‚æœå›¾ç‰‡æœ¬èº«å°±æ˜¯ WÃ—Hï¼ˆåƒç´ ç”»æ¯æ ¼=1åƒç´ ï¼‰ï¼Œç›´æ¥è¯»å–å¯¹åº”åƒç´ ï¼ˆæœ€å‡†ç¡®ï¼‰
            const direct = (iw === W && ih === H);

            const cellW = iw / W, cellH = ih / H;
            const N = 5;               // æ¯æ ¼é‡‡æ ·ç‚¹ï¼šNÃ—N
            const margin = 0.22;       // é‡‡æ ·åŒºåŸŸè¾¹è·æ¯”ä¾‹ï¼ˆé¿å…è¾¹ç¼˜çº¿æ¡å¹²æ‰°ï¼‰

            function clampI(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

            function sampleCell(x, y) {
                if (direct) {
                    const i = (y * iw + x) * 4;
                    const a = data[i + 3];
                    if (a === 0) return null;
                    return { r: data[i], g: data[i + 1], b: data[i + 2] };
                }

                const x0 = x * cellW, x1 = (x + 1) * cellW;
                const y0 = y * cellH, y1 = (y + 1) * cellH;

                const sx0 = x0 + cellW * margin;
                const sx1 = x1 - cellW * margin;
                const sy0 = y0 + cellH * margin;
                const sy1 = y1 - cellH * margin;

                let sumR = 0, sumG = 0, sumB = 0, sumW = 0;

                for (let iy = 0; iy < N; iy++) {
                    const py = Math.floor(sy0 + (iy + 0.5) * (sy1 - sy0) / N);
                    const yy = clampI(py, 0, ih - 1);
                    for (let ix = 0; ix < N; ix++) {
                        const px = Math.floor(sx0 + (ix + 0.5) * (sx1 - sx0) / N);
                        const xx = clampI(px, 0, iw - 1);
                        const i = (yy * iw + xx) * 4;
                        const a = data[i + 3] / 255;
                        if (a <= 0.05) continue;
                        sumR += data[i] * a;
                        sumG += data[i + 1] * a;
                        sumB += data[i + 2] * a;
                        sumW += a;
                    }
                }

                if (sumW <= 0.001) return null;
                return {
                    r: Math.round(sumR / sumW),
                    g: Math.round(sumG / sumW),
                    b: Math.round(sumB / sumW),
                };
            }

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const i = y * W + x;
                    const s = sampleCell(x, y);
                    if (!s) continue;
                    const best = nearestCode(s.r, s.g, s.b);
                    codeGrid[i] = best.code;
                    codeCount.set(best.code, (codeCount.get(best.code) || 0) + 1);
                }
            }

            // used colors -> sort by count desc
            const sorted = [...codeCount.entries()].sort((a, b) => b[1] - a[1]);
            let usedColors = sorted.map(([code, count]) => ({ code, hex: state.codeToHex.get(code) || '000000', count }));

            const idxMap = new Map();
            usedColors.forEach((u, i) => idxMap.set(u.code, i));

            let cells = new Int16Array(W * H);
            cells.fill(-1);
            for (let i = 0; i < W * H; i++) {
                const code = codeGrid[i];
                if (!code) continue;
                const idx = idxMap.get(code);
                if (idx === undefined) continue;
                cells[i] = idx;
            }

            const maxN = clamp(parseInt(el.maxColors.value || '0', 10) || 0, 1, 256);
            if (usedColors.length > maxN) {
                const counts = new Map(sorted);
                const limited = applyMaxColorsLimit(W, H, cells, usedColors.map(u => ({ code: u.code, hex: u.hex })), counts, maxN);
                cells = limited.cells;
                usedColors = limited.usedColors.map(u => ({ code: u.code, hex: u.hex, count: limited.counts.get(u.code) || 0 }));
                state.usedCounts = limited.counts;
            } else {
                state.usedCounts = new Map(sorted);
            }

            state.gridW = W; state.gridH = H;
            state.cells = cells;
            state.usedColors = usedColors.map(u => ({ code: u.code, hex: u.hex }));

            state.done.clear(); state.doneHistory.length = 0;
            state.history.length = 0; state.activeTarget = null;
            state.activeCode = state.usedColors[0]?.code || null;

            // è¿›å…¥æ‰¹é‡æ¨¡å¼æ—¶ï¼Œå…ˆæ¸…ç©ºé€‰åŒº
            state.multiSelected.clear();
            state.multiSelectMode = false;
            if (el.multiBar) el.multiBar.style.display = 'none';

            state.isReady = true;
            syncUIAfterBuild();
            fitToScreen();
        }

        /**********************
         * UI sync + color lists
         **********************/
        function syncUIAfterBuild() {
            state.showCode = el.showCode.checked;
            el.statusPill.textContent = 'å·²å¯¼å…¥';
            el.metaGrid.textContent = `ç½‘æ ¼ï¼š${state.gridW} Ã— ${state.gridH}`;
            updateFabOnlyText();
            refreshColorLists();
            updateMeta();
            requestDraw();
        }

        function refreshColorLists() {
            const q = (el.colorSearch.value || '').trim().toUpperCase();
            el.colorList.innerHTML = '';
            for (const u of state.usedColors) {
                if (q && !u.code.toUpperCase().includes(q)) continue;
                const count = state.usedCounts.get(u.code) || 0;
                const item = document.createElement('div');
                item.className = 'colorItem' + (u.code === state.activeCode ? ' active' : '');
                item.innerHTML = `
          <div class="ciLeft">
            <div class="sw" style="background:#${u.hex}"></div>
            <div class="ciText">
              <b>${u.code}</b>
              <small>#${u.hex}</small>
            </div>
          </div>
          <div class="ciRight">${count} é¢—</div>
        `;
                item.addEventListener('click', () => setActiveColor(u.code));
                el.colorList.appendChild(item);
            }
            refreshPickList();
            refreshEditList();
            refreshBulkList();
            refreshExportList();
        }

        function refreshPickList() {
            const q = (el.pickSearch.value || '').trim().toUpperCase();
            el.pickList.innerHTML = '';
            for (const u of state.usedColors) {
                if (q && !u.code.toUpperCase().includes(q)) continue;
                const count = state.usedCounts.get(u.code) || 0;
                const item = document.createElement('div');
                item.className = 'colorItem' + (u.code === state.activeCode ? ' active' : '');
                item.innerHTML = `
          <div class="ciLeft">
            <div class="sw" style="background:#${u.hex}"></div>
            <div class="ciText">
              <b>${u.code}</b>
              <small>#${u.hex}</small>
            </div>
          </div>
          <div class="ciRight">${count} é¢—</div>
        `;
                item.addEventListener('click', () => { setActiveColor(u.code); closeOverlay(el.pickOverlay); });
                el.pickList.appendChild(item);
            }
        }

        function refreshEditList() {
            const q = (el.editSearch.value || '').trim().toUpperCase();
            el.editList.innerHTML = '';

            const pal = state.paletteList || [];
            for (const p of pal) {
                if (state.allowedSet && !state.allowedSet.has(p.name)) continue;
                if (q && !p.name.includes(q)) continue;

                const item = document.createElement('div');
                item.className = 'colorItem';
                item.innerHTML = `
          <div class="ciLeft">
            <div class="sw" style="background:#${p.color}"></div>
            <div class="ciText">
              <b>${p.name}</b>
              <small>#${p.color}</small>
            </div>
          </div>
          <div class="ciRight">ç‚¹å‡»æ›¿æ¢</div>
        `;
                item.addEventListener('click', () => { applyEditToPickedCell(p.name, p.color); closeOverlay(el.editOverlay); });
                el.editList.appendChild(item);
            }
        }

        function setActiveColor(code) {
            state.activeCode = code;
            state.activeTarget = null;
            state.history.length = 0;
            refreshColorLists();
            updateMeta();
            requestDraw();
        }

        /**********************
         * Next / Prev / Done / Undo
         **********************/
        function idxOfCode(code) { return state.usedColors.findIndex(u => u.code === code); }

        function remainForCode(code) {
            if (!state.isReady || !code) return 0;
            const idx = idxOfCode(code);
            if (idx < 0) return 0;
            let remain = 0;
            for (let i = 0; i < state.cells.length; i++) {
                if (state.cells[i] === idx && !state.done.has(i)) remain++;
            }
            return remain;
        }

        function pickNextColorWithRemain() {
            if (!state.isReady || state.usedColors.length === 0) return null;
            const start = Math.max(0, idxOfCode(state.activeCode));
            for (let step = 1; step <= state.usedColors.length; step++) {
                const i = (start + step) % state.usedColors.length;
                const code = state.usedColors[i].code;
                if (remainForCode(code) > 0) return code;
            }
            return null;
        }

        function advanceToNextColorIfNeeded() {
            if (!state.activeCode) return false;
            if (remainForCode(state.activeCode) > 0) return false;

            const next = pickNextColorWithRemain();
            if (!next) {
                state.activeTarget = null;
                state.history.length = 0;
                el.statusPill.textContent = 'å…¨éƒ¨å®Œæˆ ğŸ‰';
                updateMeta();
                requestDraw();
                return true;
            }
            state.activeCode = next;
            state.activeTarget = null;
            state.history.length = 0;
            el.statusPill.textContent = `å·²åˆ‡æ¢é¢œè‰²ï¼š${next}`;
            refreshColorLists();
            updateMeta();
            requestDraw();
            return true;
        }

        function findNextCell() {
            if (!state.isReady || !state.activeCode) return null;
            const W = state.gridW, H = state.gridH;
            const idx = idxOfCode(state.activeCode);
            if (idx < 0) return null;

            if (state.activeTarget) {
                const k = state.activeTarget.y * W + state.activeTarget.x;
                if (!state.done.has(k) && state.cells[k] === idx) return state.activeTarget;
            }

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const k = y * W + x;
                    if (state.done.has(k)) continue;
                    if (state.cells[k] === idx) return { x, y };
                }
            }
            return null;
        }

        function nextCell() {
            if (!state.isReady) return;

            advanceToNextColorIfNeeded();

            let t = findNextCell();
            if (!t) {
                if (advanceToNextColorIfNeeded()) {
                    t = findNextCell();
                }
                if (!t) {
                    el.statusPill.textContent = 'å…¨éƒ¨å®Œæˆ ğŸ‰';
                    return;
                }
            }

            if (state.activeTarget) {
                state.history.push({ ...state.activeTarget });
                if (state.history.length > 2000) state.history.shift();
            }
            state.activeTarget = t;
            updateMeta();
            requestDraw();
        }

        function prevCell() {
            if (state.history.length === 0) return;
            state.activeTarget = state.history.pop();
            updateMeta();
            requestDraw();
        }

        function markDoneCurrent() {
            if (!state.activeTarget) return;
            const W = state.gridW;
            const k = state.activeTarget.y * W + state.activeTarget.x;
            if (!state.done.has(k)) {
                state.done.add(k);
                state.doneHistory.push(k);
                if (state.doneHistory.length > 200000) state.doneHistory.shift();
            }
            el.statusPill.textContent = 'å·²æ ‡è®°å®Œæˆ';
            updateMeta();
            requestDraw();
            nextCell();
        }

        function undoDone() {
            if (!state.isReady) return;
            if (state.doneHistory.length === 0) return;

            const W = state.gridW;
            const k = state.doneHistory.pop();
            state.done.delete(k);

            const x = k % W;
            const y = Math.floor(k / W);
            state.activeTarget = { x, y };
            state.lastPickedCell = { x, y };
            el.statusPill.textContent = 'å·²æ’¤é”€ä¸Šä¸€é¢—';
            updateMeta();
            requestDraw();
        }

        /**********************
         * ä¸€é”®å®ŒæˆæŒ‡å®šè‰²å·
         **********************/
        function markDoneAllForColor(code) {
            if (!state.isReady || !code) return;
            const idx = idxOfCode(code);
            if (idx < 0) return;

            let added = 0;
            for (let i = 0; i < state.cells.length; i++) {
                if (state.cells[i] === idx && !state.done.has(i)) {
                    state.done.add(i);
                    state.doneHistory.push(i);
                    added++;
                }
            }
            while (state.doneHistory.length > 200000) state.doneHistory.shift();

            state.activeTarget = null;
            state.history.length = 0;

            el.statusPill.textContent = added ? `å·²ä¸€é”®å®Œæˆ ${code}ï¼ˆ+${added}ï¼‰` : `é¢œè‰² ${code} å·²å…¨éƒ¨å®Œæˆ`;
            refreshColorLists();
            updateMeta();
            requestDraw();

            advanceToNextColorIfNeeded();
            nextCell();
        }

        function updateMeta() {
            el.metaGrid.textContent = state.isReady ? `ç½‘æ ¼ï¼š${state.gridW} Ã— ${state.gridH}` : 'ç½‘æ ¼ï¼šâ€”';
            el.metaColor.textContent = state.activeCode ? `å½“å‰è‰²ï¼š${state.activeCode}` : 'å½“å‰è‰²ï¼šâ€”';

            if (!state.isReady || !state.activeCode) {
                el.metaTodo.textContent = 'å‰©ä½™ï¼šâ€”';
                el.posPill.textContent = 'â€”';
                return;
            }

            const remain = remainForCode(state.activeCode);
            el.metaTodo.textContent = `å‰©ä½™ï¼š${remain}`;
            if (state.activeTarget) {
                el.posPill.textContent = `(${state.activeTarget.x + 1}, ${state.activeTarget.y + 1})`;
            } else {
                el.posPill.textContent = 'â€”';
            }
        }

        /**********************
         * Manual edit cell
         **********************/
        function openEditOverlay() {
            if (!state.lastPickedCell) {
                el.editInfo.textContent = 'å…ˆç‚¹é€‰ä¸€ä¸ªæ ¼å­';
            } else {
                el.editInfo.textContent = `å½“å‰æ ¼ï¼š(${state.lastPickedCell.x + 1}, ${state.lastPickedCell.y + 1})`;
            }
            el.editSearch.value = '';
            refreshEditList();
            openOverlay(el.editOverlay);
        }

        function applyEditColorToPickedCell(code, hex) {
            if (!state.lastPickedCell || !state.isReady) return;
            const x = state.lastPickedCell.x, y = state.lastPickedCell.y;
            const k = y * state.gridW + x;

            let idx = state.usedColors.findIndex(u => u.code === code);
            if (idx < 0) {
                state.usedColors.push({ code, hex });
                idx = state.usedColors.length - 1;
                state.usedCounts.set(code, 0);
            }

            const oldIdx = state.cells[k];
            if (oldIdx >= 0) {
                const oldCode = state.usedColors[oldIdx].code;
                state.usedCounts.set(oldCode, Math.max(0, (state.usedCounts.get(oldCode) || 0) - 1));
            }
            state.cells[k] = idx;
            state.usedCounts.set(code, (state.usedCounts.get(code) || 0) + 1);

            refreshColorLists();
            updateMeta();
            requestDraw();
        }

        /**********************
         * Canvas rendering
         **********************/
        const ctx = el.view.getContext('2d');
        let rafId = null;
        let animT = 0;

        function resizeViewCanvas() {
            const rect = el.view.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            el.view.width = Math.max(1, Math.floor(rect.width * dpr));
            el.view.height = Math.max(1, Math.floor(rect.height * dpr));
            requestDraw();
        }

        window.addEventListener('resize', () => {
            resizeViewCanvas();
            if (el.cropOverlay.style.display === 'flex') layoutCropCanvas(false);
        });

        function fitToScreen() {
            if (!state.isReady) return;
            const W = state.gridW, H = state.gridH;
            const pad = 24;
            const cw = el.view.width, ch = el.view.height;
            const zx = (cw - pad * 2) / (W * view.baseCell);
            const zy = (ch - pad * 2) / (H * view.baseCell);
            view.zoom = Math.max(0.2, Math.min(zx, zy));
            const worldW = W * view.baseCell * view.zoom;
            const worldH = H * view.baseCell * view.zoom;
            view.panX = (cw - worldW) / 2;
            view.panY = (ch - worldH) / 2;
            requestDraw();
        }

        function resetView() { view.zoom = 1; view.panX = 0; view.panY = 0; fitToScreen(); }

        function requestDraw() {
            if (rafId) return;
            rafId = requestAnimationFrame(draw);
        }

        function draw() {
            rafId = null;
            animT += 1 / 60;

            const cw = el.view.width, ch = el.view.height;
            ctx.clearRect(0, 0, cw, ch);
            ctx.fillStyle = 'rgba(0,0,0,.10)';
            ctx.fillRect(0, 0, cw, ch);

            if (!state.isReady) {
                ctx.save();
                ctx.fillStyle = 'rgba(255,255,255,.70)';
                ctx.font = `${Math.round(14 * (window.devicePixelRatio || 1))}px system-ui`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('å¯¼å…¥å›¾çº¸å›¾ç‰‡æˆ– CSV åå¼€å§‹', cw / 2, ch / 2);
                ctx.restore();
                return;
            }

            const W = state.gridW, H = state.gridH;
            const cell = view.baseCell, z = view.zoom;

            const x0 = Math.floor((-view.panX) / (cell * z)) - 1;
            const y0 = Math.floor((-view.panY) / (cell * z)) - 1;
            const x1 = Math.ceil((cw - view.panX) / (cell * z)) + 1;
            const y1 = Math.ceil((ch - view.panY) / (cell * z)) + 1;

            const vx0 = clamp(x0, 0, W), vy0 = clamp(y0, 0, H), vx1 = clamp(x1, 0, W), vy1 = clamp(y1, 0, H);

            const activeIdx = state.activeCode ? idxOfCode(state.activeCode) : -1;
            const showText = state.showCode && z >= 0.65;

            ctx.save();
            ctx.translate(view.panX, view.panY);
            ctx.scale(z, z);
            ctx.lineWidth = 1 / z;
            ctx.strokeStyle = 'rgba(0,0,0,.35)';

            for (let y = vy0; y < vy1; y++) {
                for (let x = vx0; x < vx1; x++) {
                    const k = y * W + x;
                    const idx = state.cells[k];

                    let fill = '111318';
                    if (idx >= 0) fill = state.usedColors[idx].hex;

                    let alpha = 1;
                    if (state.onlyActiveColor && activeIdx >= 0) {
                        if (idx !== activeIdx) alpha = 0.18;
                    }

                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#' + fill;
                    ctx.fillRect(x * cell, y * cell, cell, cell);
                    ctx.globalAlpha = 1;

                    ctx.strokeRect(x * cell, y * cell, cell, cell);

                    if (state.done.has(k)) {
                        ctx.save();
                        ctx.globalAlpha = 0.60;
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x * cell, y * cell, cell, cell);

                        ctx.globalAlpha = 0.92;
                        ctx.strokeStyle = 'rgba(255,255,255,.60)';
                        ctx.lineWidth = 2.4 / z;
                        ctx.beginPath();
                        ctx.moveTo(x * cell + 2, y * cell + 2);
                        ctx.lineTo(x * cell + cell - 2, y * cell + cell - 2);
                        ctx.moveTo(x * cell + cell - 2, y * cell + 2);
                        ctx.lineTo(x * cell + 2, y * cell + cell - 2);
                        ctx.stroke();
                        ctx.restore();
                    }

                    // âœ… æ‰¹é‡ç‚¹é€‰é«˜äº®
                    if (state.multiSelectMode && state.multiSelected.has(k)) {
                        ctx.save();
                        ctx.globalAlpha = 0.95;
                        ctx.lineWidth = 3.2 / z;
                        ctx.strokeStyle = 'rgba(0,180,255,.95)';
                        ctx.strokeRect(x * cell + 1.2, y * cell + 1.2, cell - 2.4, cell - 2.4);
                        ctx.restore();
                    }
                }
            }

            if (state.activeTarget) {
                const { x, y } = state.activeTarget;
                const px = x * cell, py = y * cell;
                const pulse = 0.55 + 0.45 * Math.sin(animT * 6.0);

                ctx.save();
                ctx.globalAlpha = 0.10 + 0.08 * pulse;
                ctx.fillStyle = 'rgba(255,234,0,1)';
                ctx.fillRect(px, py, cell, cell);

                ctx.globalAlpha = 0.98;
                ctx.lineWidth = (4.8 + 2.8 * pulse) / z;
                ctx.strokeStyle = 'rgba(255,234,0,.95)';
                ctx.strokeRect(px + 1.2, py + 1.2, cell - 2.4, cell - 2.4);

                ctx.globalAlpha = 0.80;
                ctx.lineWidth = 1.4 / z;
                ctx.strokeStyle = 'rgba(255,255,255,.70)';
                ctx.strokeRect(px + 5, py + 5, cell - 10, cell - 10);
                ctx.restore();
            }

            if (showText) {
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `${Math.max(9, Math.min(15, Math.floor(cell * 0.46)))}px ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace`;

                for (let y = vy0; y < vy1; y++) {
                    for (let x = vx0; x < vx1; x++) {
                        const k = y * W + x;
                        const idx = state.cells[k];
                        if (idx < 0) continue;
                        const code = state.usedColors[idx].code;
                        const rgb = hexToRgb(state.usedColors[idx].hex);
                        const lum = (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b);
                        ctx.fillStyle = lum > 140 ? 'rgba(0,0,0,.85)' : 'rgba(255,255,255,.92)';
                        ctx.fillText(code, x * cell + cell / 2, y * cell + cell / 2);
                    }
                }
                ctx.restore();
            }

            ctx.restore();

            if (state.activeTarget) requestDraw();
        }

        /**********************
         * Canvas interactions (pan/zoom + tap select)
         **********************/
        const pointer = { down: false, moved: false, startX: 0, startY: 0, pan0X: 0, pan0Y: 0, t0: 0, touches: new Map(), pinch0: null };

        function canvasToWorld(sx, sy) {
            const z = view.zoom, cell = view.baseCell;
            const wx = (sx - view.panX) / z;
            const wy = (sy - view.panY) / z;
            return { x: Math.floor(wx / cell), y: Math.floor(wy / cell) };
        }

        function onPointerDown(e) {
            el.view.setPointerCapture(e.pointerId);
            const rect = el.view.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const sx = (e.clientX - rect.left) * dpr;
            const sy = (e.clientY - rect.top) * dpr;

            pointer.touches.set(e.pointerId, { x: sx, y: sy });
            if (pointer.touches.size === 2) {
                const pts = [...pointer.touches.values()];
                pointer.pinch0 = {
                    dist: Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y),
                    zoom: view.zoom, panX: view.panX, panY: view.panY,
                    midX: (pts[0].x + pts[1].x) / 2,
                    midY: (pts[0].y + pts[1].y) / 2
                };
                return;
            }

            pointer.down = true; pointer.moved = false;
            pointer.startX = sx; pointer.startY = sy;
            pointer.pan0X = view.panX; pointer.pan0Y = view.panY;
            pointer.t0 = performance.now();
        }

        function onPointerMove(e) {
            if (!pointer.touches.has(e.pointerId)) return;
            const rect = el.view.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const sx = (e.clientX - rect.left) * dpr;
            const sy = (e.clientY - rect.top) * dpr;
            pointer.touches.set(e.pointerId, { x: sx, y: sy });

            if (pointer.touches.size === 2 && pointer.pinch0) {
                const pts = [...pointer.touches.values()];
                const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
                const midX = (pts[0].x + pts[1].x) / 2;
                const midY = (pts[0].y + pts[1].y) / 2;

                const scale = dist / pointer.pinch0.dist;
                const z0 = pointer.pinch0.zoom;
                const z1 = clamp(z0 * scale, 0.2, 10);

                const wx = (pointer.pinch0.midX - pointer.pinch0.panX) / z0;
                const wy = (pointer.pinch0.midY - pointer.pinch0.panY) / z0;

                view.zoom = z1;
                view.panX = midX - wx * z1;
                view.panY = midY - wy * z1;

                requestDraw();
                return;
            }

            if (!pointer.down) return;
            const dx = sx - pointer.startX, dy = sy - pointer.startY;
            if (Math.abs(dx) + Math.abs(dy) > 4) pointer.moved = true;
            view.panX = pointer.pan0X + dx;
            view.panY = pointer.pan0Y + dy;
            requestDraw();
        }

        function onPointerUp(e) {
            pointer.touches.delete(e.pointerId);
            if (pointer.touches.size < 2) pointer.pinch0 = null;
            if (!pointer.down) return;
            pointer.down = false;

            const rect = el.view.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const sx = (e.clientX - rect.left) * dpr;
            const sy = (e.clientY - rect.top) * dpr;
            const dt = performance.now() - pointer.t0;

            if (!pointer.moved && dt < 300 && state.isReady) {
                const hit = canvasToWorld(sx, sy);
                if (hit.x >= 0 && hit.x < state.gridW && hit.y >= 0 && hit.y < state.gridH) {
                    const k = hit.y * state.gridW + hit.x;

                    if (state.multiSelectMode) {
                        // âœ… æ‰¹é‡ç‚¹é€‰ï¼šåˆ‡æ¢é€‰ä¸­/å–æ¶ˆé€‰ä¸­
                        if (state.multiSelected.has(k)) state.multiSelected.delete(k);
                        else state.multiSelected.add(k);

                        state.lastPickedCell = { x: hit.x, y: hit.y };
                        state.activeTarget = { x: hit.x, y: hit.y };

                        updateMultiBar();
                        updateMeta();
                        requestDraw();
                        return;
                    }

                    state.lastPickedCell = { x: hit.x, y: hit.y };
                    state.activeTarget = { x: hit.x, y: hit.y };
                    updateMeta();
                    requestDraw();
                }
            }
        }

        function onWheel(e) {
            if (!state.isReady) return;
            e.preventDefault();
            const rect = el.view.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const sx = (e.clientX - rect.left) * dpr;
            const sy = (e.clientY - rect.top) * dpr;

            const zoomFactor = Math.exp(-e.deltaY * 0.0012);
            const z0 = view.zoom;
            const z1 = clamp(z0 * zoomFactor, 0.2, 10);

            const wx = (sx - view.panX) / z0;
            const wy = (sy - view.panY) / z0;

            view.zoom = z1;
            view.panX = sx - wx * z1;
            view.panY = sy - wy * z1;
            requestDraw();
        }

        el.view.addEventListener('pointerdown', onPointerDown);
        el.view.addEventListener('pointermove', onPointerMove);
        el.view.addEventListener('pointerup', onPointerUp);
        el.view.addEventListener('pointercancel', onPointerUp);
        el.view.addEventListener('wheel', onWheel, { passive: false });

        /**********************
         * Bulk overlay list
         **********************/
        function refreshBulkList() {
            if (!state.isReady) { el.bulkList.innerHTML = ''; return; }
            const q = (el.bulkSearch.value || '').trim().toUpperCase();
            el.bulkList.innerHTML = '';

            const arr = [...state.usedColors].slice().sort((a, b) => (state.usedCounts.get(b.code) || 0) - (state.usedCounts.get(a.code) || 0));

            for (const u of arr) {
                if (q && !u.code.toUpperCase().includes(q)) continue;
                const total = state.usedCounts.get(u.code) || 0;
                const remain = remainForCode(u.code);
                const item = document.createElement('div');
                item.className = 'colorItem' + (u.code === state.activeCode ? ' active' : '');
                item.innerHTML = `
          <div class="ciLeft">
            <div class="sw" style="background:#${u.hex}"></div>
            <div class="ciText">
              <b>${u.code}</b>
              <small>#${u.hex}</small>
            </div>
          </div>
          <div class="ciRight">${remain}/${total} å‰©ä½™</div>
        `;
                item.addEventListener('click', () => {
                    closeOverlay(el.bulkOverlay);
                    markDoneAllForColor(u.code);
                });
                el.bulkList.appendChild(item);
            }
        }

        function openBulkOverlay() {
            if (!state.isReady) { alert('è¯·å…ˆå¯¼å…¥å›¾çº¸'); return; }
            el.bulkSearch.value = '';
            refreshBulkList();
            openOverlay(el.bulkOverlay);
        }

        /**********************
         * Export
         **********************/
        const exportState = {
            includeSet: new Set(),
        };

        function openExportOverlay() {
            if (!state.isReady) { alert('è¯·å…ˆå¯¼å…¥å›¾çº¸'); return; }
            exportState.includeSet = new Set(state.usedColors.map(u => u.code));
            el.exportSearch.value = '';
            el.exportBlankExcluded.checked = true;
            refreshExportList();
            openOverlay(el.exportOverlay);
        }

        function refreshExportList() {
            if (!el.exportOverlay) return;
            if (!state.isReady) { el.exportList.innerHTML = ''; return; }

            const q = (el.exportSearch.value || '').trim().toUpperCase();
            el.exportList.innerHTML = '';

            const arr = [...state.usedColors].slice().sort((a, b) => (state.usedCounts.get(b.code) || 0) - (state.usedCounts.get(a.code) || 0));

            for (const u of arr) {
                if (q && !u.code.toUpperCase().includes(q)) continue;

                const total = state.usedCounts.get(u.code) || 0;
                const remain = remainForCode(u.code);
                const checked = exportState.includeSet.has(u.code);

                const item = document.createElement('div');
                item.className = 'colorItem';
                item.style.cursor = 'default';
                item.innerHTML = `
          <div class="checkRow">
            <input type="checkbox" ${checked ? 'checked' : ''} />
            <div class="ciLeft" style="flex:1">
              <div class="sw" style="background:#${u.hex}"></div>
              <div class="ciText">
                <b>${u.code}</b>
                <small>#${u.hex}</small>
              </div>
            </div>
            <div class="ciRight">${remain}/${total} å‰©ä½™</div>
          </div>
        `;
                const cb = item.querySelector('input[type="checkbox"]');
                cb.addEventListener('change', () => {
                    if (cb.checked) exportState.includeSet.add(u.code);
                    else exportState.includeSet.delete(u.code);
                });
                el.exportList.appendChild(item);
            }
        }

        function calcExportStats(includeSet) {
            const total = new Map();
            const done = new Map();

            for (let i = 0; i < state.cells.length; i++) {
                const idx = state.cells[i];
                if (idx < 0) continue;
                const code = state.usedColors[idx].code;
                if (!includeSet.has(code)) continue;

                total.set(code, (total.get(code) || 0) + 1);
                if (state.done.has(i)) done.set(code, (done.get(code) || 0) + 1);
            }

            const rows = [];
            for (const [code, t] of total.entries()) {
                const d = done.get(code) || 0;
                const hex = state.codeToHex.get(code) || state.usedColors.find(x => x.code === code)?.hex || '000000';
                rows.push({ code, hex, total: t, done: d, remain: Math.max(0, t - d) });
            }
            rows.sort((a, b) => b.total - a.total);
            return rows;
        }

        function exportGridCSV() {
            const includeSet = exportState.includeSet;
            const blankExcluded = el.exportBlankExcluded.checked;

            const W = state.gridW, H = state.gridH;
            const lines = [];
            for (let y = 0; y < H; y++) {
                const row = [];
                for (let x = 0; x < W; x++) {
                    const k = y * W + x;
                    const idx = state.cells[k];
                    if (idx < 0) { row.push(''); continue; }
                    const code = state.usedColors[idx].code;
                    if (includeSet.has(code)) row.push(code);
                    else row.push(blankExcluded ? '' : code);
                }
                lines.push(row.join(','));
            }
            downloadText(`mard_grid_${timeStamp()}.csv`, lines.join('\n'), 'text/csv;charset=utf-8');
        }

        function exportStatsCSV() {
            const includeSet = exportState.includeSet;
            const rows = calcExportStats(includeSet);
            let csv = 'code,hex,total,done,remain\n';
            for (const r of rows) {
                csv += `${r.code},#${r.hex},${r.total},${r.done},${r.remain}\n`;
            }
            downloadText(`mard_stats_${timeStamp()}.csv`, csv, 'text/csv;charset=utf-8');
        }

        function exportAsJSON() {
            const includeSet = exportState.includeSet;
            const blankExcluded = el.exportBlankExcluded.checked;
            const W = state.gridW, H = state.gridH;

            const cells = [];
            for (let y = 0; y < H; y++) {
                const row = [];
                for (let x = 0; x < W; x++) {
                    const k = y * W + x;
                    const idx = state.cells[k];
                    if (idx < 0) { row.push(''); continue; }
                    const code = state.usedColors[idx].code;
                    if (includeSet.has(code)) row.push(code);
                    else row.push(blankExcluded ? '' : code);
                }
                cells.push(row);
            }

            const stats = calcExportStats(includeSet);
            const excluded = state.usedColors.map(u => u.code).filter(c => !includeSet.has(c));

            const out = {
                app: 'mard-grid-helper',
                exportedAt: new Date().toISOString(),
                grid: { W, H },
                palette: 'mard',
                includeCodes: [...includeSet],
                excludedCodes: excluded,
                blankExcludedInGrid: !!blankExcluded,
                stats,
                cells,
                done: [...state.done],
            };

            downloadText(`mard_export_${timeStamp()}.json`, JSON.stringify(out, null, 2), 'application/json;charset=utf-8');
        }

        function exportAsPNG() {
            const includeSet = exportState.includeSet;
            const blankExcluded = el.exportBlankExcluded.checked;
            const W = state.gridW, H = state.gridH;

            const mode = (el.exportPngMode && el.exportPngMode.value) ? el.exportPngMode.value : 'grid_only';

            const cell = 20;

            const stats = (mode === 'grid_codes_legend') ? calcExportStats(includeSet) : [];
            const rowH = 18;
            const legendCols = (mode === 'grid_codes_legend') ? Math.max(1, Math.floor((W * cell) / 220)) : 1;
            const legendRows = (mode === 'grid_codes_legend') ? Math.ceil(stats.length / legendCols) : 0;
            const legendH = (mode === 'grid_codes_legend') ? (legendRows * rowH + 34) : 0;

            const out = document.createElement('canvas');
            out.width = W * cell;
            out.height = H * cell + legendH;

            const g = out.getContext('2d');
            g.clearRect(0, 0, out.width, out.height);

            // èƒŒæ™¯
            g.fillStyle = '#0b0c10';
            g.fillRect(0, 0, out.width, out.height);

            // ç”»æ ¼å­ç”»
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const k = y * W + x;
                    const idx = state.cells[k];
                    if (idx < 0) continue;
                    const code = state.usedColors[idx].code;

                    if (!includeSet.has(code) && blankExcluded) continue;

                    const hex = state.usedColors[idx].hex;
                    g.fillStyle = '#' + hex;
                    g.fillRect(x * cell, y * cell, cell, cell);

                    if (mode === 'grid_codes_legend' && includeSet.has(code)) {
                        // æ–‡å­—é¢œè‰²ï¼šè‡ªåŠ¨é»‘/ç™½
                        const rgb = hexToRgb(hex);
                        const lum = (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b);
                        g.fillStyle = (lum > 145) ? 'rgba(0,0,0,.92)' : 'rgba(255,255,255,.92)';
                        const len = String(code).length;
                        const fs = (len <= 2) ? 11 : (len === 3 ? 10 : 9);
                        g.font = `bold ${fs}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
                        g.textAlign = 'center';
                        g.textBaseline = 'middle';
                        g.fillText(code, x * cell + cell / 2, y * cell + cell / 2);
                    }
                }
            }

            // ç½‘æ ¼çº¿ï¼ˆåªè¦†ç›–æ ¼å­åŒºåŸŸï¼‰
            g.strokeStyle = 'rgba(0,0,0,.55)';
            g.lineWidth = 1;
            for (let x = 0; x <= W; x++) {
                g.beginPath();
                g.moveTo(x * cell + 0.5, 0);
                g.lineTo(x * cell + 0.5, H * cell);
                g.stroke();
            }
            for (let y = 0; y <= H; y++) {
                g.beginPath();
                g.moveTo(0, y * cell + 0.5);
                g.lineTo(W * cell, y * cell + 0.5);
                g.stroke();
            }

            // ç”»ç»Ÿè®¡ï¼ˆä¸‹æ–¹ï¼‰
            if (mode === 'grid_codes_legend') {
                const top = H * cell;
                g.fillStyle = '#ffffff';
                g.fillRect(0, top, out.width, legendH);

                g.fillStyle = '#111';
                g.font = 'bold 14px system-ui, -apple-system, Segoe UI, Roboto, Arial';
                g.textAlign = 'left';
                g.textBaseline = 'alphabetic';
                g.fillText(`è‰²å·ç»Ÿè®¡ï¼ˆå…± ${stats.reduce((s, r) => s + r.total, 0)} æ ¼ï¼‰`, 12, top + 22);

                g.font = '12px system-ui, -apple-system, Segoe UI, Roboto, Arial';
                const colW = out.width / legendCols;

                for (let i = 0; i < stats.length; i++) {
                    const col = i % legendCols;
                    const row = Math.floor(i / legendCols);
                    const x0 = col * colW + 12;
                    const y0 = top + 34 + row * rowH;

                    const r = stats[i];
                    // swatch
                    g.fillStyle = '#' + r.hex;
                    g.fillRect(x0, y0 - 11, 12, 12);
                    g.strokeStyle = 'rgba(0,0,0,.35)';
                    g.strokeRect(x0 + 0.5, y0 - 10.5, 11, 11);

                    g.fillStyle = '#111';
                    g.textAlign = 'left';
                    g.textBaseline = 'middle';
                    g.fillText(`${r.code}  Ã— ${r.total}`, x0 + 18, y0 - 5);
                }
            }

            out.toBlob((blob) => {
                if (!blob) { alert('å¯¼å‡º PNG å¤±è´¥'); return; }
                const suffix = (mode === 'grid_codes_legend') ? 'grid_codes' : 'grid';
                downloadBlob(`mard_${suffix}_${timeStamp()}.png`, blob);
            }, 'image/png');
        }

        /**********************
         * Wire UI events
         **********************/
        el.colorSearch.addEventListener('input', refreshColorLists);
        el.pickSearch.addEventListener('input', refreshPickList);
        el.editSearch.addEventListener('input', refreshEditList);
        el.bulkSearch.addEventListener('input', refreshBulkList);
        el.exportSearch.addEventListener('input', refreshExportList);

        el.showCode.addEventListener('change', () => { state.showCode = el.showCode.checked; requestDraw() });

        el.limitSehao.addEventListener('change', () => {
            rebuildPaletteMaps();
            rerunFromLastImage('å·²åˆ‡æ¢è‰²å·é™åˆ¶å¹¶é‡æ–°è¯†åˆ«ï¼ˆä½¿ç”¨åŒä¸€å¼ è£å‰ªå›¾ï¼‰', 'å·²åˆ‡æ¢è‰²å·é™åˆ¶ï¼ˆè¯·é‡æ–°å¯¼å…¥/è£å‰ªåè¯†åˆ«ï¼‰');
        });

        el.fitBtn.addEventListener('click', fitToScreen);
        el.resetViewBtn.addEventListener('click', resetView);
        el.zoomInBtn.addEventListener('click', () => { view.zoom = clamp(view.zoom * 1.15, 0.2, 10); requestDraw() });
        el.zoomOutBtn.addEventListener('click', () => { view.zoom = clamp(view.zoom / 1.15, 0.2, 10); requestDraw() });

        el.nextBtn.addEventListener('click', nextCell);
        el.prevBtn.addEventListener('click', prevCell);
        el.doneBtn.addEventListener('click', markDoneCurrent);
        el.undoBtn.addEventListener('click', undoDone);

        el.editCellBtn.addEventListener('click', openEditOverlay);
        el.editClose.addEventListener('click', () => closeOverlay(el.editOverlay));

        el.cropClose.addEventListener('click', () => closeOverlay(el.cropOverlay));
        el.cropSkip.addEventListener('click', () => { closeOverlay(el.cropOverlay); buildFromImage(crop.img); });
        el.cropApply.addEventListener('click', applyCropToImage);
        el.cropCanvas.addEventListener('pointerdown', onCropPointerDown);
        el.cropCanvas.addEventListener('pointermove', onCropPointerMove);
        el.cropCanvas.addEventListener('pointerup', onCropPointerUp);
        el.cropCanvas.addEventListener('pointercancel', onCropPointerUp);

        el.pickClose.addEventListener('click', () => closeOverlay(el.pickOverlay));
        el.bulkClose.addEventListener('click', () => closeOverlay(el.bulkOverlay));

        el.bulkBtn.addEventListener('click', openBulkOverlay);
        el.exportBtn.addEventListener('click', openExportOverlay);

        el.exportClose.addEventListener('click', () => closeOverlay(el.exportOverlay));
        el.exportSelectAll.addEventListener('click', () => {
            exportState.includeSet = new Set(state.usedColors.map(u => u.code));
            refreshExportList();
        });
        el.exportSelectNone.addEventListener('click', () => {
            exportState.includeSet = new Set();
            refreshExportList();
        });

        el.exportGridCSV.addEventListener('click', exportGridCSV);
        el.exportStatsCSV.addEventListener('click', exportStatsCSV);
        el.exportJSON.addEventListener('click', exportAsJSON);
        el.exportPNG.addEventListener('click', exportAsPNG);

        // FAB æŠ˜å /å±•å¼€ï¼ˆé»˜è®¤å±•å¼€ï¼Œå¯è®°å¿†ï¼‰
        function setFabCollapsed(collapsed) {
            el.fab.classList.toggle('collapsed', !!collapsed);
            localStorage.setItem('fab_collapsed', collapsed ? '1' : '0');
        }
        const fabCollapsed = localStorage.getItem('fab_collapsed') === '1';
        setFabCollapsed(fabCollapsed);

        el.fabMain.addEventListener('click', () => {
            setFabCollapsed(!el.fab.classList.contains('collapsed'));
        });

        // âœ… FABï¼šé¢æ¿æ˜¾ç¤º/éšè—
        el.fabPanelToggle.addEventListener('click', () => {
            const hidden = document.body.classList.contains('panelHidden');
            setPanelHidden(!hidden);
        });

        // âœ… FABï¼šåªçœ‹å½“å‰è‰²
        el.fabOnly.addEventListener('click', toggleOnlyActiveColor);

        // âœ… FABï¼šå½“å‰æ ¼å±…ä¸­
        el.fabCenter.addEventListener('click', centerOnCurrentTarget);

        // FAB è¡Œä¸º
        el.fabPick.addEventListener('click', () => { if (!state.isReady) return alert('è¯·å…ˆå¯¼å…¥å›¾çº¸'); openOverlay(el.pickOverlay); });
        el.fabFit.addEventListener('click', fitToScreen);
        el.fabPrev.addEventListener('click', prevCell);
        el.fabNext.addEventListener('click', nextCell);
        el.fabDone.addEventListener('click', markDoneCurrent);
        el.fabUndo.addEventListener('click', undoDone);
        el.fabBulk.addEventListener('click', openBulkOverlay);
        el.fabExport.addEventListener('click', openExportOverlay);
        if (el.fabMulti) el.fabMulti.addEventListener('click', () => {
            if (!state.isReady) return;
            if (state.multiSelectMode) exitMultiSelectMode();
            else enterMultiSelectMode();
        });

        // palette select
        initPaletteSelect();
        if (el.paletteSelect) el.paletteSelect.addEventListener('change', () => {
            setPaletteKey(el.paletteSelect.value);
        });

        // filter overlay
        if (el.filterBtn) el.filterBtn.addEventListener('click', () => {
            refreshFilterOverlayUI();
            openOverlay(el.filterOverlay);
        });
        if (el.filterClose) el.filterClose.addEventListener('click', () => closeOverlay(el.filterOverlay));
        if (el.filterClear) el.filterClear.addEventListener('click', () => {
            setFilterMode('none');
            state.filterSeries = new Set();
            state.filterNames = new Set();
            persistFilterSets();
            rebuildPaletteMaps();
            refreshFilterOverlayUI();
            rerunFromLastImage('å·²æ¸…ç©ºè¯†åˆ«é™åˆ¶å¹¶é‡æ–°è¯†åˆ«', 'å·²æ¸…ç©ºè¯†åˆ«é™åˆ¶ï¼ˆè¯·é‡æ–°å¯¼å…¥/è£å‰ªåè¯†åˆ«ï¼‰');
        });
        if (el.filterApply) el.filterApply.addEventListener('click', applyFilterFromOverlay);
        if (el.filterModeNone) el.filterModeNone.addEventListener('change', refreshFilterOverlayUI);
        if (el.filterModeSeries) el.filterModeSeries.addEventListener('change', refreshFilterOverlayUI);
        if (el.filterModeName) el.filterModeName.addEventListener('change', refreshFilterOverlayUI);
        if (el.filterNameSearch) el.filterNameSearch.addEventListener('input', refreshFilterNameList);
        if (el.filterSeriesAll) el.filterSeriesAll.addEventListener('click', () => {
            el.filterSeriesList?.querySelectorAll('input[type="checkbox"][data-series]').forEach(chk => chk.checked = true);
        });
        if (el.filterSeriesNone) el.filterSeriesNone.addEventListener('click', () => {
            el.filterSeriesList?.querySelectorAll('input[type="checkbox"][data-series]').forEach(chk => chk.checked = false);
        });
        if (el.filterNameAll) el.filterNameAll.addEventListener('click', () => {
            el.filterNameList?.querySelectorAll('input[type="checkbox"][data-name]').forEach(chk => chk.checked = true);
        });
        if (el.filterNameNone) el.filterNameNone.addEventListener('click', () => {
            el.filterNameList?.querySelectorAll('input[type="checkbox"][data-name]').forEach(chk => chk.checked = false);
        });

        // multi bar
        if (el.multiCancel) el.multiCancel.addEventListener('click', exitMultiSelectMode);
        if (el.multiConfirm) el.multiConfirm.addEventListener('click', confirmMultiDone);


        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeOverlay(el.cropOverlay);
                closeOverlay(el.pickOverlay);
                closeOverlay(el.editOverlay);
                closeOverlay(el.bulkOverlay);
                closeOverlay(el.exportOverlay);
            }
            if (e.key === 'n' || e.key === 'N') nextCell();
            if (e.key === 'p' || e.key === 'P') prevCell();
            if (e.key === 'd' || e.key === 'D') markDoneCurrent();
            if (e.key === 'u' || e.key === 'U') undoDone();
        });

        /**********************
         * Import handlers
         **********************/
        el.allowedFile.addEventListener('change', async () => {
            const f = el.allowedFile.files?.[0];
            if (!f) return;
            const text = await f.text();
            try {
                rebuildPaletteMaps();
                state.allowedList = parseAllowedCodesCSV(text);
                rebuildPaletteMaps();
                el.statusPill.textContent = `å·²è½½å…¥ sehaoï¼š${state.allowedList.length} ä¸ªè‰²å·ï¼ˆéœ€é‡æ–°å¯¼å…¥ï¼‰`;
            } catch (err) {
                el.statusPill.textContent = 'sehao è§£æå¤±è´¥';
                alert(err.message || String(err));
            }
        });

        el.imgFile.addEventListener('change', () => {
            const f = el.imgFile.files?.[0];
            if (!f) return;
            const url = URL.createObjectURL(f);
            const img = new Image();
            img.onload = () => { URL.revokeObjectURL(url); openCrop(img); };
            img.src = url;
            el.statusPill.textContent = 'å·²é€‰æ‹©å›¾ç‰‡ï¼ˆå¾…è£å‰ªï¼‰';
        });

        el.csvFile.addEventListener('change', async () => {
            const f = el.csvFile.files?.[0];
            if (!f) return;
            const text = await f.text();
            try {
                const { W, H, rows } = parseCodeCSV(text);
                el.gridW.value = W; el.gridH.value = H;
                el.autoFit.checked = false;
                buildFromCSV(rows, W, H);
            } catch (err) {
                el.statusPill.textContent = 'CSV è§£æå¤±è´¥';
                alert(err.message || String(err));
            }
        });

        /**********************
         * Init
         **********************/
        // 1) å®‰è£…æŒ‰é’®é˜²è¿ç‚¹æ”¾å¤§
        installNoDoubleTapZoomForButtons();

        // 2) è¿˜åŸé¢æ¿éšè—çŠ¶æ€
        const panelHidden = localStorage.getItem('panel_hidden') === '1';
        setPanelHidden(panelHidden);

        // 3) æ›´æ–° FAB æ–‡æ¡ˆ
        updateFabOnlyText();

        // 4) canvas åˆå§‹åŒ–
        resizeViewCanvas();
        requestDraw();
    </script>
</body>

</html>
