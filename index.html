<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>æ‹¼è±†é€æ ¼é«˜äº®åŠ©æ‰‹ï¼ˆMardï¼‰</title>
    <style>
        :root {
            --bg: #0b0c10;
            --panel: #12141b;
            --panel2: #0f1117;
            --text: #e8eaf0;
            --muted: #a7adbd;
            --line: #2a2f3b;
            --accent: #7aa2ff;
            --danger: #ff5d5d;
            --ok: #42d392;
            --shadow: 0 10px 30px rgba(0, 0, 0, .35);
            --radius: 16px;
            --btnh: 46px;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            color: var(--text);
            background: radial-gradient(1200px 800px at 20% -10%, rgba(122, 162, 255, .20), transparent 60%),
                radial-gradient(1000px 700px at 110% 10%, rgba(66, 211, 146, .12), transparent 60%), var(--bg);
            overflow: hidden;
        }

        /* ====== é˜²æ­¢ iOS / å¹³æ¿ï¼šç‚¹è¾“å…¥æ¡†æ”¾å¤§ & è¿ç‚¹æŒ‰é’®æ”¾å¤§ ====== */
        input,
        select,
        textarea {
            font-size: 16px;
        }

        button,
        .btn,
        .fabBtn,
        .fabMain,
        .colorItem,
        .pill,
        .chip {
            touch-action: manipulation;
        }

        /* ====== ä¸Šä¸‹åˆ†æ ï¼šé¢æ¿åœ¨ä¸Šï¼Œç”»å¸ƒåœ¨ä¸‹ï¼ˆä¸å†å·¦å³åˆ†æ ï¼‰ ====== */
        .app {
            height: 100dvh;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 12px;
            padding-bottom: calc(12px + env(safe-area-inset-bottom));
            min-height: 0;
        }

        /* åˆ†æ éšè—æ¨¡å¼ */
        body.panelHidden .app {
            gap: 0;
        }

        body.panelHidden .side {
            display: none !important;
        }

        .card {
            background: linear-gradient(180deg, rgba(18, 20, 27, .92), rgba(12, 14, 20, .92));
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow: hidden
        }

        /* é¡¶éƒ¨é¢æ¿ï¼šé™åˆ¶é«˜åº¦ï¼Œå†…å®¹å†…éƒ¨æ»šåŠ¨ */
        .side {
            display: flex;
            flex-direction: column;
            min-height: 0;
            max-height: 24dvh;
        }

        @media (max-height:720px) {
            .side {
                max-height: 24dvh;
            }
        }

        @media (max-width:980px) {
            .side {
                max-height: 24dvh;
            }
        }

        .header {
            padding: 14px 14px 10px 14px;
            border-bottom: 1px solid rgba(255, 255, 255, .08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px
        }

        .title {
            display: flex;
            flex-direction: column;
            gap: 2px
        }

        .title b {
            font-size: 14px;
            letter-spacing: .2px
        }

        .title small {
            font-size: 12px;
            color: var(--muted)
        }

        .chip {
            font-size: 12px;
            color: #cdd3e6;
            background: rgba(122, 162, 255, .12);
            border: 1px solid rgba(122, 162, 255, .25);
            padding: 6px 10px;
            border-radius: 999px;
            white-space: nowrap
        }

        .content {
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0;
            overflow: auto;
            /* é¡¶éƒ¨é¢æ¿å†…éƒ¨æ»šåŠ¨ */
            padding-bottom: 14px;
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center
        }

        label {
            font-size: 12px;
            color: var(--muted)
        }

        input[type="file"],
        input[type="number"],
        input[type="text"],
        select {
            background: rgba(255, 255, 255, .06);
            color: var(--text);
            border: 1px solid rgba(255, 255, 255, .10);
            border-radius: 12px;
            padding: 10px 12px;
            outline: none;
            width: 100%
        }

        input[type="number"] {
            padding: 10px 10px
        }

        .grid2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px
        }

        .btn {
            height: var(--btnh);
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, .12);
            background: rgba(255, 255, 255, .06);
            color: var(--text);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 0 14px;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-weight: 600;
            letter-spacing: .2px
        }

        .btn:active {
            transform: translateY(1px)
        }

        .btn.primary {
            background: rgba(122, 162, 255, .18);
            border-color: rgba(122, 162, 255, .35)
        }

        .btn.ok {
            background: rgba(66, 211, 146, .16);
            border-color: rgba(66, 211, 146, .30)
        }

        .btn.danger {
            background: rgba(255, 93, 93, .14);
            border-color: rgba(255, 93, 93, .25)
        }

        .btn.small {
            height: 38px;
            border-radius: 12px;
            font-size: 13px
        }

        .btn.wide {
            width: 100%
        }

        .toggle {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px 12px;
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 14px;
            background: rgba(0, 0, 0, .15)
        }

        .toggle input {
            width: 18px;
            height: 18px
        }

        .hr {
            height: 1px;
            background: rgba(255, 255, 255, .08);
            margin: 4px 0
        }

        .colors {
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 8px
        }

        .colorsTop {
            display: flex;
            gap: 10px;
            align-items: center
        }

        .colorsTop input {
            flex: 1
        }

        .list {
            min-height: 0;
            overflow: auto;
            padding-right: 4px
        }

        .colorItem {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px 10px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, .08);
            background: rgba(0, 0, 0, .12);
            cursor: pointer;
            margin-bottom: 8px
        }

        .colorItem.active {
            border-color: rgba(122, 162, 255, .45);
            box-shadow: 0 0 0 2px rgba(122, 162, 255, .14) inset;
            background: rgba(122, 162, 255, .10)
        }

        .sw {
            width: 22px;
            height: 22px;
            border-radius: 7px;
            border: 1px solid rgba(255, 255, 255, .12);
            flex: 0 0 auto
        }

        .ciLeft {
            display: flex;
            align-items: center;
            gap: 10px;
            min-width: 0
        }

        .ciText {
            display: flex;
            flex-direction: column;
            min-width: 0
        }

        .ciText b {
            font-size: 13px;
            line-height: 1.1
        }

        .ciText small {
            font-size: 12px;
            color: var(--muted);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap
        }

        .ciRight {
            font-variant-numeric: tabular-nums;
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap
        }

        /* åº•éƒ¨ç”»å¸ƒåŒº */
        .stage {
            display: flex;
            flex-direction: column;
            min-height: 0;
            flex: 1 1 auto;
            position: relative
        }

        .stageTop {
            padding: 12px 14px;
            border-bottom: 1px solid rgba(255, 255, 255, .08);
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap
        }

        .stageTop .meta {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            color: var(--muted);
            font-size: 12px
        }

        .stageMain {
            position: relative;
            flex: 1;
            min-height: 0;
            background: linear-gradient(180deg, rgba(255, 255, 255, .02), rgba(0, 0, 0, .05))
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none
        }

        .pill {
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, .06);
            border: 1px solid rgba(255, 255, 255, .10)
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, .62);
            display: none;
            align-items: center;
            justify-content: center;
            padding: 16px;
            z-index: 999
        }

        .modal {
            width: min(980px, 96vw);
            max-height: min(92vh, 900px);
            display: flex;
            flex-direction: column
        }

        .modalHead {
            padding: 12px 14px;
            border-bottom: 1px solid rgba(255, 255, 255, .08);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px
        }

        .modalBody {
            padding: 12px 14px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-height: 0
        }

        .modalBody .hint {
            color: var(--muted);
            font-size: 12px;
            line-height: 1.5
        }

        .modalCanvasWrap {
            background: rgba(0, 0, 0, .22);
            border: 1px solid rgba(255, 255, 255, .08);
            border-radius: 14px;
            overflow: hidden;
            height: min(60vh, 560px)
        }

        #cropCanvas {
            width: 100%;
            height: 100%;
            touch-action: none
        }

        .modalFoot {
            padding: 12px 14px;
            border-top: 1px solid rgba(255, 255, 255, .08);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            flex-wrap: wrap
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 11px;
            padding: 2px 6px;
            border: 1px solid rgba(255, 255, 255, .14);
            border-radius: 6px;
            color: #d7dcf0;
            background: rgba(255, 255, 255, .06)
        }

        /* ====== æ‚¬æµ®æŒ‰é’®ï¼ˆå¯æ”¶èµ·ï¼Œé»˜è®¤å±•å¼€ï¼‰ ====== */
        .fab {
            position: fixed;
            right: 12px;
            bottom: calc(12px + env(safe-area-inset-bottom));
            z-index: 60;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: none;
        }

        .fab * {
            pointer-events: auto;
        }

        .fabPanel {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end;
            transform-origin: bottom right;
            transition: transform .18s ease, opacity .18s ease;
        }

        .fab.collapsed .fabPanel {
            transform: translateY(10px) scale(.98);
            opacity: 0;
            pointer-events: none;
        }

        .fabMain {
            height: 52px;
            padding: 0 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .14);
            background: rgba(18, 20, 27, .92);
            color: var(--text);
            box-shadow: var(--shadow);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-weight: 800;
            letter-spacing: .2px;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .fabMain:active {
            transform: translateY(1px)
        }

        .fabBtn {
            height: 44px;
            padding: 0 14px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, .14);
            background: rgba(12, 14, 20, .88);
            color: var(--text);
            box-shadow: 0 10px 24px rgba(0, 0, 0, .30);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-weight: 700;
            font-size: 13px;
            white-space: nowrap;
        }

        .fabBtn.primary {
            background: rgba(122, 162, 255, .18);
            border-color: rgba(122, 162, 255, .35)
        }

        .fabBtn.ok {
            background: rgba(66, 211, 146, .16);
            border-color: rgba(66, 211, 146, .30)
        }

        .fabBtn.danger {
            background: rgba(255, 93, 93, .14);
            border-color: rgba(255, 93, 93, .25)
        }

        /* å¯¼å‡ºåˆ—è¡¨é¡¹é‡Œçš„ checkbox */
        .checkRow {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .checkRow input[type="checkbox"] {
            width: 18px;
            height: 18px;
            flex: 0 0 auto;
        }
    </style>
</head>

<body>
    <div class="app">
        <aside class="side card">
            <div class="header">
                <div class="title">
                    <b>æ‹¼è±†é€æ ¼é«˜äº®åŠ©æ‰‹</b>
                    <small>å¯¼å…¥å›¾çº¸ â†’ é€‰é¢œè‰² â†’ ä¸‹ä¸€æ ¼/å®Œæˆï¼ˆä¸è·³è§†å›¾ï¼‰</small>
                </div>
                <div class="chip">Mard è‰²å·</div>
            </div>

            <div class="content">
                <div class="row">
                    <div style="flex:1">
                        <label>å¯¼å…¥å›¾çº¸å›¾ç‰‡ï¼ˆå…ˆè£å‰ªï¼‰</label>
                        <input id="imgFile" type="file" accept="image/*">
                    </div>
                </div>

                <div class="row">
                    <div style="flex:1">
                        <label>æˆ–è€…ï¼šå¯¼å…¥ CSV è‰²å·å›¾çº¸ï¼ˆä¸é é¢œè‰²è¯†åˆ«ï¼‰</label>
                        <input id="csvFile" type="file" accept=".csv,text/csv,text/plain">
                    </div>
                </div>

                <div class="grid2">
                    <div>
                        <label>ç½‘æ ¼å®½ Wï¼ˆâ‰¤104ï¼‰</label>
                        <input id="gridW" type="number" min="1" max="104" value="52">
                    </div>
                    <div>
                        <label>ç½‘æ ¼é«˜ Hï¼ˆâ‰¤104ï¼‰</label>
                        <input id="gridH" type="number" min="1" max="104" value="52">
                    </div>
                </div>

                <div class="toggle">
                    <input id="autoFit" type="checkbox" checked>
                    <div style="display:flex; flex-direction:column; gap:2px">
                        <b style="font-size:13px">è‡ªåŠ¨æŒ‰å›¾ç‰‡æ¯”ä¾‹é€‚é…</b>
                        <span style="font-size:12px; color:var(--muted)">å¯ç”¨æ—¶ä»¥ 104 ä¸ºæœ€å¤§è¾¹ï¼Œè‡ªåŠ¨ç®—
                            W/H</span>
                    </div>
                </div>

                <div class="grid2">
                    <div>
                        <label>æœ€å¤§ä½¿ç”¨é¢œè‰²æ•° Nï¼ˆå›¾ç‰‡å¯¼å…¥æ—¶ç”Ÿæ•ˆï¼‰</label>
                        <input id="maxColors" type="number" min="1" max="256" value="80">
                    </div>
                    <div>
                        <label>å¯¼å…¥è‰²å·é™åˆ¶è¡¨ sehao.csvï¼ˆå¯é€‰ï¼‰</label>
                        <input id="allowedFile" type="file" accept=".csv,text/csv,text/plain">
                    </div>
                </div>

                <div class="toggle">
                    <input id="limitSehao" type="checkbox" checked>
                    <div style="display:flex; flex-direction:column; gap:2px">
                        <b style="font-size:13px">ä½¿ç”¨ sehao.csv è‰²å·é™åˆ¶</b>
                        <span style="font-size:12px; color:var(--muted)">é¿å…ç”Ÿæˆä¸åœ¨æ¸…å•ä¸­çš„è‰²å·</span>
                    </div>
                </div>

                <div class="grid2">
                    <button class="btn small" id="fitBtn" type="button">é€‚é…å±å¹•</button>
                    <button class="btn small" id="resetViewBtn" type="button">é‡ç½®è§†å›¾</button>
                </div>

                <div class="grid2">
                    <button class="btn small" id="zoomOutBtn" type="button">ç¼©å°</button>
                    <button class="btn small" id="zoomInBtn" type="button">æ”¾å¤§</button>
                </div>

                <div class="grid2">
                    <button class="btn small" id="exportBtn" type="button">å¯¼å‡º</button>
                    <button class="btn small" id="bulkBtn" type="button">ä¸€é”®å®Œæˆè‰²å·</button>
                </div>

                <div class="toggle">
                    <input id="showCode" type="checkbox" checked>
                    <div style="display:flex; flex-direction:column; gap:2px">
                        <b style="font-size:13px">æ ¼å­å†…æ˜¾ç¤ºè‰²å·</b>
                        <span style="font-size:12px; color:var(--muted)">ç¼©æ”¾è¾ƒå°æ—¶ä¼šè‡ªåŠ¨ä¸ç”»å­—</span>
                    </div>
                </div>

                <!-- âœ… â€œåªçœ‹å½“å‰é¢œè‰²â€ å·²ç§»åˆ°æ‚¬æµ®æŒ‰é’®é‡Œï¼ˆè¿™é‡Œä¸å†æ”¾å¼€å…³ï¼‰ -->

                <div class="hr"></div>

                <div class="grid2">
                    <button class="btn primary wide" id="nextBtn" type="button">ä¸‹ä¸€æ ¼</button>
                    <button class="btn ok wide" id="doneBtn" type="button">å®Œæˆæ­¤æ ¼</button>
                </div>

                <div class="grid2">
                    <button class="btn wide" id="prevBtn" type="button">ä¸Šä¸€æ ¼</button>
                    <button class="btn danger wide" id="undoBtn" type="button">æ’¤é”€å®Œæˆ</button>
                </div>

                <div class="row" style="justify-content:space-between">
                    <span class="pill" id="statusPill">æœªå¯¼å…¥</span>
                    <span class="pill" id="posPill">â€”</span>
                </div>

                <div class="colors">
                    <div class="colorsTop">
                        <input id="colorSearch" type="text" placeholder="æœç´¢è‰²å·ï¼ˆä¾‹å¦‚ A1 / C20 / M15ï¼‰">
                        <button class="btn small" id="editCellBtn" type="button"
                            title="ç‚¹é€‰ä¸€ä¸ªæ ¼å­åå¯æ‰‹åŠ¨æ”¹è‰²">æ”¹è‰²</button>
                    </div>
                    <div class="list" id="colorList"></div>
                </div>
            </div>
        </aside>

        <main class="stage card">
            <div class="stageTop">
                <div class="meta">
                    <span>æ“ä½œï¼š</span>
                    <span class="pill">æ‹–æ‹½å¹³ç§»</span>
                    <span class="pill">æ»šè½®/åŒæŒ‡ç¼©æ”¾</span>
                    <span class="pill">ç‚¹æ ¼å­ï¼šå®šä½</span>
                </div>
                <div class="meta">
                    <span id="metaGrid">ç½‘æ ¼ï¼šâ€”</span>
                    <span id="metaColor">å½“å‰è‰²ï¼šâ€”</span>
                    <span id="metaTodo">å‰©ä½™ï¼šâ€”</span>
                </div>
            </div>
            <div class="stageMain">
                <canvas id="view"></canvas>
            </div>
        </main>
    </div>

    <!-- æ‚¬æµ®æ“ä½œï¼ˆé»˜è®¤å±•å¼€ï¼Œå¯æ”¶èµ·ï¼‰ -->
    <div class="fab" id="fab">
        <div class="fabPanel" id="fabPanel">
            <button class="fabBtn" id="fabPanelToggle" type="button">ğŸ§¾ éšè—é¢æ¿</button>
            <button class="fabBtn" id="fabOnly" type="button">ğŸ‘ï¸ åªçœ‹å½“å‰è‰²ï¼šå…³</button>
            <button class="fabBtn" id="fabCenter" type="button">ğŸ¯ å½“å‰æ ¼å±…ä¸­</button>

            <button class="fabBtn primary" id="fabPick" type="button">ğŸ¨ é€‰é¢œè‰²</button>
            <button class="fabBtn" id="fabFit" type="button">ğŸ§² é€‚é…</button>
            <button class="fabBtn" id="fabPrev" type="button">â¬…ï¸ ä¸Šä¸€æ ¼</button>
            <button class="fabBtn primary" id="fabNext" type="button">â¡ï¸ ä¸‹ä¸€æ ¼</button>
            <button class="fabBtn ok" id="fabDone" type="button">âœ… å®Œæˆæ­¤æ ¼</button>
            <button class="fabBtn danger" id="fabUndo" type="button">â†©ï¸ æ’¤é”€</button>
            <button class="fabBtn ok" id="fabBulk" type="button">âš¡ ä¸€é”®å®Œæˆè‰²å·</button>
            <button class="fabBtn" id="fabExport" type="button">ğŸ“¦ å¯¼å‡º</button>
        </div>
        <button class="fabMain" id="fabMain" type="button">â‰¡ æ“ä½œé¢æ¿</button>
    </div>

    <!-- è£å‰ª -->
    <div class="overlay" id="cropOverlay">
        <div class="modal card">
            <div class="modalHead">
                <div class="title">
                    <b>è£å‰ªå›¾çº¸</b>
                    <small>æ‹–åŠ¨/ç¼©æ”¾è£å‰ªæ¡† â†’ åº”ç”¨è£å‰ªï¼ˆä¹Ÿå¯è·³è¿‡ï¼‰</small>
                </div>
                <button class="btn small" id="cropClose" type="button">å…³é—­</button>
            </div>
            <div class="modalBody">
                <div class="hint">æç¤ºï¼šè£å‰ªæ¡†å¯æ‹–åŠ¨ï¼›å››è§’å¯ç¼©æ”¾ã€‚ç§»åŠ¨ç«¯ç›´æ¥æ‰‹æŒ‡æ“ä½œå³å¯ã€‚</div>
                <div class="modalCanvasWrap"><canvas id="cropCanvas"></canvas></div>
                <div class="hint">å¿«æ·é”®ï¼ˆç”µè„‘ï¼‰ï¼š<span class="kbd">Esc</span> å…³é—­</div>
            </div>
            <div class="modalFoot">
                <button class="btn" id="cropSkip" type="button">è·³è¿‡è£å‰ª</button>
                <button class="btn primary" id="cropApply" type="button">åº”ç”¨è£å‰ª</button>
            </div>
        </div>
    </div>

    <!-- é€‰é¢œè‰² -->
    <div class="overlay" id="pickOverlay">
        <div class="modal card" style="width:min(720px,96vw)">
            <div class="modalHead">
                <div class="title">
                    <b>é€‰æ‹©å½“å‰é¢œè‰²</b>
                    <small>ç‚¹é€‰ä¸€ä¸ªè‰²å·å³å¯</small>
                </div>
                <button class="btn small" id="pickClose" type="button">å…³é—­</button>
            </div>
            <div class="modalBody" style="min-height:0">
                <input id="pickSearch" type="text" placeholder="æœç´¢è‰²å·ï¼ˆA1 / C20 / M15ï¼‰">
                <div class="list" id="pickList" style="max-height:60vh"></div>
            </div>
        </div>
    </div>

    <!-- æ‰‹åŠ¨æ”¹è‰² -->
    <div class="overlay" id="editOverlay">
        <div class="modal card" style="width:min(720px,96vw)">
            <div class="modalHead">
                <div class="title">
                    <b>æ‰‹åŠ¨æ”¹è‰²</b>
                    <small id="editInfo">â€”</small>
                </div>
                <button class="btn small" id="editClose" type="button">å…³é—­</button>
            </div>
            <div class="modalBody">
                <div class="hint">ç”¨äºä¿®æ­£â€œé¢œè‰²è¯†åˆ«â€è¯¯åˆ¤ï¼šå…ˆç‚¹é€‰ä¸€ä¸ªæ ¼å­ï¼Œå†åœ¨è¿™é‡Œé€‰æ­£ç¡®è‰²å·ã€‚</div>
                <input id="editSearch" type="text" placeholder="æœç´¢è‰²å·ï¼ˆä¾‹å¦‚ A1ï¼‰">
                <div class="list" id="editList" style="max-height:55vh"></div>
            </div>
        </div>
    </div>

    <!-- ä¸€é”®å®ŒæˆæŒ‡å®šè‰²å· -->
    <div class="overlay" id="bulkOverlay">
        <div class="modal card" style="width:min(720px,96vw)">
            <div class="modalHead">
                <div class="title">
                    <b>ä¸€é”®å®ŒæˆæŸä¸ªè‰²å·</b>
                    <small>é€‰æ‹©åï¼šè¯¥è‰²æ‰€æœ‰æœªå®Œæˆæ ¼å­éƒ½ä¼šæ ‡è®°å®Œæˆ</small>
                </div>
                <button class="btn small" id="bulkClose" type="button">å…³é—­</button>
            </div>
            <div class="modalBody" style="min-height:0">
                <input id="bulkSearch" type="text" placeholder="æœç´¢è‰²å·ï¼ˆA1 / C20 / M15ï¼‰">
                <div class="list" id="bulkList" style="max-height:60vh"></div>
                <div class="hint">æç¤ºï¼šå¯ç”¨â€œæ’¤é”€å®Œæˆâ€é€é¢—æ’¤é”€ï¼ˆæ‰¹é‡ä¼šåŠ å…¥å®Œæˆè®°å½•æ ˆï¼‰ã€‚</div>
            </div>
        </div>
    </div>

    <!-- å¯¼å‡º -->
    <div class="overlay" id="exportOverlay">
        <div class="modal card" style="width:min(860px,96vw)">
            <div class="modalHead">
                <div class="title">
                    <b>å¯¼å‡º</b>
                    <small>å¯¼å‡ºå›¾çº¸ / è‰²å·ç»Ÿè®¡ / PNG / JSONï¼Œå¹¶å¯å‹¾é€‰â€œä¸å¯¼å‡ºæŸäº›è‰²å·â€</small>
                </div>
                <button class="btn small" id="exportClose" type="button">å…³é—­</button>
            </div>

            <div class="modalBody" style="min-height:0">
                <div class="grid2">
                    <div>
                        <label>æœç´¢è‰²å·ï¼ˆå‹¾é€‰åˆ—è¡¨ç”¨ï¼‰</label>
                        <input id="exportSearch" type="text" placeholder="ä¾‹å¦‚ A1 / C20 / M15">
                    </div>
                    <div class="toggle" style="margin:0">
                        <input id="exportBlankExcluded" type="checkbox" checked>
                        <div style="display:flex; flex-direction:column; gap:2px">
                            <b style="font-size:13px">å›¾çº¸é‡Œå°†æœªå¯¼å‡ºçš„è‰²å·ç•™ç©º</b>
                            <span
                                style="font-size:12px; color:var(--muted)">ä¸å‹¾é€‰åˆ™å›¾çº¸ä»ä¿ç•™è¿™äº›è‰²å·ï¼Œä»…ç»Ÿè®¡ä¸å¯¼å‡º</span>
                        </div>
                    </div>
                </div>

                <div class="grid2">
                    <button class="btn small" id="exportSelectAll" type="button">å…¨é€‰</button>
                    <button class="btn small" id="exportSelectNone" type="button">å…¨ä¸é€‰</button>
                </div>

                <div class="hint">å‹¾é€‰ = å…è®¸å¯¼å‡ºï¼›ä¸å‹¾é€‰ = ä¸å¯¼å‡ºè¯¥è‰²å·ï¼ˆç»Ÿè®¡/å›¾çº¸/PNG/JSONéƒ½ä¼šæŒ‰æ­¤è®¾ç½®å¤„ç†ï¼‰ã€‚</div>

                <div class="list" id="exportList" style="max-height:36vh"></div>
            </div>

            <div class="modalFoot">
                <button class="btn" id="exportGridCSV" type="button">å¯¼å‡ºå›¾çº¸ CSV</button>
                <button class="btn" id="exportStatsCSV" type="button">å¯¼å‡ºç»Ÿè®¡ CSV</button>
                <button class="btn" id="exportJSON" type="button">å¯¼å‡º JSON</button>
                <button class="btn primary" id="exportPNG" type="button">å¯¼å‡º PNG</button>
            </div>
        </div>
    </div>

    <script>
        /**********************
         * 0) å¸¸é‡ï¼šç½‘æ ¼æœ€å¤§ 104
         **********************/
        const MAX_GRID = 104;

        /**********************
         * 1) ä½ çš„ mard è‰²å·è¡¨ï¼šname -> hex
         **********************/
        var allPalettes = new Map();
        allPalettes.set("mard",
            [
                { name: 'A1', color: 'fff5ca' },
                { name: 'A2', color: 'ffffcc' },
                { name: 'A3', color: 'fff297' },
                { name: 'A4', color: 'fff651' },
                { name: 'A5', color: 'ffdb4d' },
                { name: 'A6', color: 'fcc73b' },
                { name: 'A7', color: 'fe8443' },
                { name: 'A8', color: 'e5c62d' },
                { name: 'A9', color: 'fbaa72' },
                { name: 'A10', color: 'fd9443' },
                { name: 'A11', color: 'ffcf7c' },
                { name: 'A12', color: 'fdbc9e' },
                { name: 'A14', color: 'ff7443' },
                { name: 'A16', color: 'fff49e' },
                { name: 'A17', color: 'fde676' },
                { name: 'A18', color: 'ffb67b' },
                { name: 'A19', color: 'fa9285' },
                { name: 'A20', color: 'fee27e' },
                { name: 'B1', color: 'eaf149' },
                { name: 'B2', color: 'b6eb45' },
                { name: 'B3', color: '9af5a8' },
                { name: 'B4', color: '51ff51' },
                { name: 'B5', color: '6fd363' },
                { name: 'B6', color: '79ebc7' },
                { name: 'B7', color: '3bb48b' },
                { name: 'B8', color: '13904c' },
                { name: 'B9', color: '28523a' },
                { name: 'B10', color: 'ace1d9' },
                { name: 'B11', color: '52641d' },
                { name: 'B12', color: '206a4f' },
                { name: 'B13', color: 'c7ff85' },
                { name: 'B14', color: 'd0ed39' },
                { name: 'B15', color: '205726' },
                { name: 'B16', color: 'ccffaa' },
                { name: 'B17', color: 'b6c130' },
                { name: 'B18', color: 'e4f954' },
                { name: 'B19', color: '00d0a1' },
                { name: 'B20', color: 'c4ffd7' },
                { name: 'B21', color: '157c74' },
                { name: 'B22', color: '0d5349' },
                { name: 'B23', color: '32451d' },
                { name: 'B24', color: 'e4fb9f' },
                { name: 'B25', color: '5c9083' },
                { name: 'B26', color: 'a9a44e' },
                { name: 'C1', color: 'e0ffe2' },
                { name: 'C2', color: 'b9f6ed' },
                { name: 'C3', color: 'a8e1fc' },
                { name: 'C4', color: '84d2ff' },
                { name: 'C5', color: '24b9e4' },
                { name: 'C6', color: '78bdf8' },
                { name: 'C7', color: '3c8aec' },
                { name: 'C8', color: '195dc4' },
                { name: 'C9', color: '2e26cc' },
                { name: 'C10', color: '30d9ed' },
                { name: 'C11', color: '00c4d0' },
                { name: 'C12', color: '1a3758' },
                { name: 'C13', color: 'b4d7ff' },
                { name: 'C14', color: 'e0fff9' },
                { name: 'C15', color: '00cbd2' },
                { name: 'C16', color: '0a5491' },
                { name: 'C17', color: '7be7f4' },
                { name: 'C18', color: '264257' },
                { name: 'C19', color: '259bb9' },
                { name: 'C20', color: '157cbf' },
                { name: 'C21', color: 'deeefe' },
                { name: 'C22', color: '7fc0d4' },
                { name: 'D1', color: 'b9cffe' },
                { name: 'D2', color: '9ca6db' },
                { name: 'D3', color: '224eb1' },
                { name: 'D4', color: '2e4770' },
                { name: 'D5', color: 'c56fb8' },
                { name: 'D6', color: 'aa76e4' },
                { name: 'D7', color: '7e4dc7' },
                { name: 'D8', color: 'e0cdff' },
                { name: 'D9', color: 'c9befd' },
                { name: 'D10', color: '351d4f' },
                { name: 'D11', color: 'c1c2ff' },
                { name: 'D12', color: 'daafe4' },
                { name: 'D13', color: 'c64dae' },
                { name: 'D14', color: '9735b3' },
                { name: 'D15', color: '46297d' },
                { name: 'D16', color: 'e3e4ff' },
                { name: 'D17', color: 'c9d9fd' },
                { name: 'D18', color: 'b87bd5' },
                { name: 'D19', color: 'e8cbfa' },
                { name: 'D20', color: 'a73ae9' },
                { name: 'D21', color: '8b339b' },
                { name: 'D22', color: '595093' },
                { name: 'D23', color: 'efe7fc' },
                { name: 'D24', color: '7f77ea' },
                { name: 'D25', color: '423bc0' },
                { name: 'E1', color: 'ffd1cc' },
                { name: 'E2', color: 'ffcaea' },
                { name: 'E3', color: 'fb8dc5' },
                { name: 'E4', color: 'ee78ac' },
                { name: 'E5', color: 'f653a6' },
                { name: 'E6', color: 'fd2f81' },
                { name: 'E7', color: 'a2176a' },
                { name: 'E8', color: 'ffd8e8' },
                { name: 'E9', color: 'ea8cda' },
                { name: 'E10', color: 'bf3974' },
                { name: 'E11', color: 'fee7e2' },
                { name: 'E12', color: 'fcafdd' },
                { name: 'E13', color: 'a61284' },
                { name: 'E14', color: 'fdd2bf' },
                { name: 'E15', color: 'f3d1d7' },
                { name: 'E16', color: 'fff3eb' },
                { name: 'E17', color: 'fae8f8' },
                { name: 'E18', color: 'fdd1ea' },
                { name: 'E19', color: 'f6d3f3' },
                { name: 'E20', color: 'f4d7e9' },
                { name: 'E21', color: 'd6b3b9' },
                { name: 'E22', color: 'c685b0' },
                { name: 'E23', color: 'a089a3' },
                { name: 'F1', color: 'fda098' },
                { name: 'F2', color: 'fa6a62' },
                { name: 'F3', color: 'ec4a59' },
                { name: 'F4', color: 'ff452c' },
                { name: 'F5', color: 'ff0000' },
                { name: 'F6', color: 'b53710' },
                { name: 'F7', color: '811530' },
                { name: 'F8', color: 'bb082f' },
                { name: 'F9', color: 'e67088' },
                { name: 'F10', color: '8c420c' },
                { name: 'F11', color: '6f3329' },
                { name: 'F12', color: 'f9425e' },
                { name: 'F13', color: 'd14b30' },
                { name: 'F14', color: 'fdaca9' },
                { name: 'F15', color: 'dd0c2c' },
                { name: 'F16', color: 'fddedc' },
                { name: 'F17', color: 'fbaf9f' },
                { name: 'F18', color: 'e0804d' },
                { name: 'F19', color: 'c64b60' },
                { name: 'G1', color: 'fee5c7' },
                { name: 'G2', color: 'fcceb7' },
                { name: 'G3', color: 'f9c2a4' },
                { name: 'G4', color: 'dcb99a' },
                { name: 'G5', color: 'f2a76d' },
                { name: 'G6', color: 'ee9867' },
                { name: 'G7', color: '91664e' },
                { name: 'G8', color: '4d312c' },
                { name: 'G9', color: 'eabb85' },
                { name: 'G10', color: 'bf9143' },
                { name: 'G11', color: 'e4c896' },
                { name: 'G12', color: 'ddb986' },
                { name: 'G13', color: 'd19058' },
                { name: 'G14', color: '856a54' },
                { name: 'G15', color: 'f5f3dc' },
                { name: 'G16', color: 'f2dfce' },
                { name: 'G17', color: '5d5249' },
                { name: 'G18', color: 'ffedd9' },
                { name: 'G19', color: 'eca450' },
                { name: 'G20', color: 'b0623e' },
                { name: 'G21', color: 'cb906e' },
                { name: 'H2', color: 'ffffff' },
                { name: 'H3', color: 'aeaeae' },
                { name: 'H4', color: '979296' },
                { name: 'H5', color: '606060' },
                { name: 'H6', color: '353537' },
                { name: 'H7', color: '000000' },
                { name: 'H8', color: 'f7e6f0' },
                { name: 'H9', color: 'e6e3dc' },
                { name: 'H10', color: 'e5e2f3' },
                { name: 'H11', color: 'cecdcb' },
                { name: 'H12', color: 'fff2e2' },
                { name: 'H13', color: 'ece1cb' },
                { name: 'H14', color: 'c5ced8' },
                { name: 'H15', color: '9facc7' },
                { name: 'H16', color: '241d1a' },
                { name: 'H17', color: 'f6f4f5' },
                { name: 'H18', color: 'fffdf1' },
                { name: 'H19', color: 'f8f3eb' },
                { name: 'H20', color: 'a0acb1' },
                { name: 'M1', color: 'ccd7c9' },
                { name: 'M2', color: '91aa94' },
                { name: 'M3', color: '718898' },
                { name: 'M4', color: 'dacec2' },
                { name: 'M5', color: 'dbd6b6' },
                { name: 'M6', color: 'c8b999' },
                { name: 'M7', color: 'c1aca7' },
                { name: 'M8', color: 'b09699' },
                { name: 'M9', color: 'ab9787' },
                { name: 'M10', color: 'bb9fb9' },
                { name: 'M11', color: '9b809f' },
                { name: 'M12', color: '5a474c' },
                { name: 'M13', color: 'dda89a' },
                { name: 'M14', color: 'c0725d' },
                { name: 'M15', color: '86848a' },
            ]
        );

        // ç»Ÿä¸€æ ¼å¼åŒ–ï¼šname å¤§å†™ã€color å»æ‰ #ã€è½¬å°å†™
        function normalizePalette(arr) {
            return (arr || []).map(p => ({
                name: String(p.name || '').trim().toUpperCase(),
                color: String(p.color || '').trim().replace(/^#/, '').toLowerCase()
            })).filter(p => p.name && /^[0-9a-f]{6}$/.test(p.color));
        }

        const MARD_PALETTE = normalizePalette(allPalettes.get("mard"));
        const DEFAULT_ALLOWED_CODES = MARD_PALETTE.map(p => p.name);

        /**********************
         * State
         **********************/
        const state = {
            gridW: 0,
            gridH: 0,
            cells: null,
            usedColors: [],
            usedCounts: new Map(),
            codeToHex: new Map(),
            activeCode: null,
            activeTarget: null,
            history: [],
            done: new Set(),
            doneHistory: [],
            lastPickedCell: null,

            // âœ… â€œåªçœ‹å½“å‰è‰²â€ æ”¹ä¸ºæ‚¬æµ®æŒ‰é’®æ§åˆ¶ + è®°å¿†
            onlyActiveColor: (localStorage.getItem('only_active_color') === '1'),

            showCode: true,
            allowedSet: null,
            allowedList: null,
            isReady: false,
        };

        const view = { zoom: 1, panX: 0, panY: 0, baseCell: 18 };

        /**********************
         * Elements
         **********************/
        const el = {
            imgFile: document.getElementById('imgFile'),
            csvFile: document.getElementById('csvFile'),
            allowedFile: document.getElementById('allowedFile'),
            gridW: document.getElementById('gridW'),
            gridH: document.getElementById('gridH'),
            autoFit: document.getElementById('autoFit'),
            limitSehao: document.getElementById('limitSehao'),
            maxColors: document.getElementById('maxColors'),

            fitBtn: document.getElementById('fitBtn'),
            resetViewBtn: document.getElementById('resetViewBtn'),
            zoomInBtn: document.getElementById('zoomInBtn'),
            zoomOutBtn: document.getElementById('zoomOutBtn'),
            exportBtn: document.getElementById('exportBtn'),
            bulkBtn: document.getElementById('bulkBtn'),

            showCode: document.getElementById('showCode'),

            nextBtn: document.getElementById('nextBtn'),
            prevBtn: document.getElementById('prevBtn'),
            doneBtn: document.getElementById('doneBtn'),
            undoBtn: document.getElementById('undoBtn'),

            statusPill: document.getElementById('statusPill'),
            posPill: document.getElementById('posPill'),

            colorSearch: document.getElementById('colorSearch'),
            colorList: document.getElementById('colorList'),

            metaGrid: document.getElementById('metaGrid'),
            metaColor: document.getElementById('metaColor'),
            metaTodo: document.getElementById('metaTodo'),

            view: document.getElementById('view'),
            editCellBtn: document.getElementById('editCellBtn'),

            // crop
            cropOverlay: document.getElementById('cropOverlay'),
            cropCanvas: document.getElementById('cropCanvas'),
            cropClose: document.getElementById('cropClose'),
            cropSkip: document.getElementById('cropSkip'),
            cropApply: document.getElementById('cropApply'),

            // pick
            pickOverlay: document.getElementById('pickOverlay'),
            pickClose: document.getElementById('pickClose'),
            pickSearch: document.getElementById('pickSearch'),
            pickList: document.getElementById('pickList'),

            // edit
            editOverlay: document.getElementById('editOverlay'),
            editClose: document.getElementById('editClose'),
            editSearch: document.getElementById('editSearch'),
            editList: document.getElementById('editList'),
            editInfo: document.getElementById('editInfo'),

            // bulk
            bulkOverlay: document.getElementById('bulkOverlay'),
            bulkClose: document.getElementById('bulkClose'),
            bulkSearch: document.getElementById('bulkSearch'),
            bulkList: document.getElementById('bulkList'),

            // export
            exportOverlay: document.getElementById('exportOverlay'),
            exportClose: document.getElementById('exportClose'),
            exportSearch: document.getElementById('exportSearch'),
            exportList: document.getElementById('exportList'),
            exportBlankExcluded: document.getElementById('exportBlankExcluded'),
            exportSelectAll: document.getElementById('exportSelectAll'),
            exportSelectNone: document.getElementById('exportSelectNone'),
            exportGridCSV: document.getElementById('exportGridCSV'),
            exportStatsCSV: document.getElementById('exportStatsCSV'),
            exportJSON: document.getElementById('exportJSON'),
            exportPNG: document.getElementById('exportPNG'),

            // fab
            fab: document.getElementById('fab'),
            fabMain: document.getElementById('fabMain'),
            fabPick: document.getElementById('fabPick'),
            fabFit: document.getElementById('fabFit'),
            fabPrev: document.getElementById('fabPrev'),
            fabNext: document.getElementById('fabNext'),
            fabDone: document.getElementById('fabDone'),
            fabUndo: document.getElementById('fabUndo'),
            fabBulk: document.getElementById('fabBulk'),
            fabExport: document.getElementById('fabExport'),

            // âœ… new fab buttons
            fabOnly: document.getElementById('fabOnly'),
            fabCenter: document.getElementById('fabCenter'),
            fabPanelToggle: document.getElementById('fabPanelToggle'),
        };

        /**********************
         * Utils
         **********************/
        function clamp(v, min, max) { return Math.max(min, Math.min(max, v)) }
        function hexToRgb(hex) {
            const m = /^([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : { r: 0, g: 0, b: 0 };
        }
        function srgbToLinear(u) { u /= 255; return u <= 0.04045 ? u / 12.92 : Math.pow((u + 0.055) / 1.055, 2.4) }
        function rgbToLab(r, g, b) {
            const R = srgbToLinear(r), G = srgbToLinear(g), B = srgbToLinear(b);
            let x = (R * 0.4124564 + G * 0.3575761 + B * 0.1804375) / 0.95047;
            let y = (R * 0.2126729 + G * 0.7151522 + B * 0.0721750) / 1.00000;
            let z = (R * 0.0193339 + G * 0.1191920 + B * 0.9503041) / 1.08883;
            const f = t => t > 0.008856 ? Math.cbrt(t) : (7.787 * t + 16 / 116);
            const fx = f(x), fy = f(y), fz = f(z);
            return { L: 116 * fy - 16, a: 500 * (fx - fy), b: 200 * (fy - fz) };
        }
        function deltaE76(l1, l2) {
            const dL = l1.L - l2.L, da = l1.a - l2.a, db = l1.b - l2.b;
            return dL * dL + da * da + db * db;
        }
        function openOverlay(node) { node.style.display = 'flex' }
        function closeOverlay(node) { node.style.display = 'none' }

        function timeStamp() {
            const d = new Date();
            const pad = n => String(n).padStart(2, '0');
            return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}_${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
        }

        function downloadBlob(filename, blob) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            a.remove();
            setTimeout(() => URL.revokeObjectURL(a.href), 1000);
        }
        function downloadText(filename, text, mime) {
            downloadBlob(filename, new Blob([text], { type: mime || 'text/plain;charset=utf-8' }));
        }

        /**********************
         * âœ… å¹³æ¿è¿ç‚¹æŒ‰é’®æ”¾å¤§ï¼šä»…å¯¹æŒ‰é’®é˜»æ­¢ double-tap zoom
         **********************/
        function installNoDoubleTapZoomForButtons() {
            const targets = document.querySelectorAll('button, .btn, .fabBtn, .fabMain');
            targets.forEach(t => {
                let last = 0;
                t.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    if (now - last <= 320) {
                        e.preventDefault();
                    }
                    last = now;
                }, { passive: false });
            });
        }

        /**********************
         * âœ… é¡¶éƒ¨åˆ†æ æ˜¾ç¤º/éšè—ï¼ˆè®°å¿†ï¼‰
         **********************/
        function setPanelHidden(hidden) {
            document.body.classList.toggle('panelHidden', !!hidden);
            localStorage.setItem('panel_hidden', hidden ? '1' : '0');
            updateFabPanelToggleText();

            // é¢æ¿é«˜åº¦å˜åŒ–ä¼šå½±å“ canvas å°ºå¯¸ï¼šé‡ç®—å¹¶å°½é‡é€‚é…
            setTimeout(() => {
                resizeViewCanvas();
                if (state.isReady) fitToScreen();
            }, 50);
        }
        function updateFabPanelToggleText() {
            const hidden = document.body.classList.contains('panelHidden');
            el.fabPanelToggle.textContent = hidden ? 'ğŸ§¾ æ˜¾ç¤ºé¢æ¿' : 'ğŸ§¾ éšè—é¢æ¿';
            el.fabPanelToggle.classList.toggle('primary', !hidden);
        }

        /**********************
         * âœ… â€œåªçœ‹å½“å‰è‰²â€ æ‚¬æµ®æŒ‰é’®
         **********************/
        function updateFabOnlyText() {
            const on = !!state.onlyActiveColor;
            el.fabOnly.textContent = on ? 'ğŸ‘ï¸ åªçœ‹å½“å‰è‰²ï¼šå¼€' : 'ğŸ‘ï¸ åªçœ‹å½“å‰è‰²ï¼šå…³';
            el.fabOnly.classList.toggle('primary', on);
        }
        function toggleOnlyActiveColor() {
            state.onlyActiveColor = !state.onlyActiveColor;
            localStorage.setItem('only_active_color', state.onlyActiveColor ? '1' : '0');
            updateFabOnlyText();
            requestDraw();
        }

        /**********************
         * âœ… å½“å‰é«˜äº®æ ¼å±…ä¸­
         **********************/
        function centerOnCurrentTarget() {
            if (!state.isReady) return alert('è¯·å…ˆå¯¼å…¥å›¾çº¸');
            const t = state.activeTarget || state.lastPickedCell;
            if (!t) return alert('è¿˜æ²¡æœ‰é€‰ä¸­/é«˜äº®ä»»ä½•æ ¼å­');
            const cw = el.view.width, ch = el.view.height;
            const z = view.zoom, cell = view.baseCell;

            const wx = (t.x + 0.5) * cell;
            const wy = (t.y + 0.5) * cell;

            view.panX = cw / 2 - wx * z;
            view.panY = ch / 2 - wy * z;
            requestDraw();
        }

        /**********************
         * Palette maps + allowed list
         **********************/
        function rebuildPaletteMaps() {
            state.codeToHex.clear();
            for (const p of MARD_PALETTE) { state.codeToHex.set(p.name, p.color); }

            if (el.limitSehao.checked) {
                const list = state.allowedList ?? DEFAULT_ALLOWED_CODES;
                state.allowedSet = new Set(list);
            } else {
                state.allowedSet = null;
            }
        }
        rebuildPaletteMaps();

        function parseAllowedCodesCSV(text) {
            const tokens = text.replace(/\r/g, '\n').split(/\n|,|;|\t|\s+/).map(s => s.trim()).filter(Boolean);
            const set = new Set();
            for (const t of tokens) {
                const code = t.toUpperCase();
                if (state.codeToHex.has(code)) set.add(code);
            }
            return [...set];
        }

        /**********************
         * CSV mode: parse code grid
         **********************/
        function parseCodeCSV(text) {
            const lines = text.replace(/\r/g, '\n').split('\n').map(s => s.trim()).filter(Boolean);
            const rows = lines.map(line => line.split(/[,;\t ]+/).map(x => x.trim()).filter(Boolean));
            const H = rows.length;
            const W = Math.max(...rows.map(r => r.length));
            if (W < 1 || H < 1) throw new Error('CSV ä¸ºç©ºæˆ–æ ¼å¼ä¸å¯¹');
            if (W > MAX_GRID || H > MAX_GRID) throw new Error(`CSV ç½‘æ ¼è¶…è¿‡ ${MAX_GRID}Ã—${MAX_GRID}`);
            for (const r of rows) { while (r.length < W) r.push(''); }
            return { W, H, rows };
        }

        function buildFromCSV(rows, W, H) {
            rebuildPaletteMaps();
            state.gridW = W; state.gridH = H;
            state.done.clear(); state.doneHistory.length = 0;
            state.history.length = 0; state.activeTarget = null;

            const codeCount = new Map();
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const code = (rows[y][x] || '').trim().toUpperCase();
                    if (!code) continue;
                    if (state.allowedSet && !state.allowedSet.has(code)) continue;
                    if (!state.codeToHex.has(code)) continue;
                    codeCount.set(code, (codeCount.get(code) || 0) + 1);
                }
            }
            const used = [...codeCount.entries()].sort((a, b) => b[1] - a[1]).map(([code, count]) => ({ code, hex: state.codeToHex.get(code), count }));
            state.usedColors = used.map(u => ({ code: u.code, hex: u.hex }));
            state.usedCounts = new Map(used.map(u => [u.code, u.count]));

            const idxMap = new Map();
            state.usedColors.forEach((u, i) => idxMap.set(u.code, i));
            state.cells = new Int16Array(W * H);
            state.cells.fill(-1);
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const code = (rows[y][x] || '').trim().toUpperCase();
                    if (!code) continue;
                    if (state.allowedSet && !state.allowedSet.has(code)) continue;
                    const idx = idxMap.get(code);
                    if (idx === undefined) continue;
                    state.cells[y * W + x] = idx;
                }
            }

            state.activeCode = state.usedColors[0]?.code || null;
            state.isReady = true;
            syncUIAfterBuild();
            fitToScreen();
        }

        /**********************
         * Crop (image import)
         **********************/
        const crop = {
            img: null,
            displayScale: 1,
            rect: { x: 0, y: 0, w: 0, h: 0 },
            dragging: false,
            dragMode: null,
            last: { x: 0, y: 0 },
            offsetX: 0, offsetY: 0,
        };

        function openCrop(img) {
            crop.img = img;
            openOverlay(el.cropOverlay);
            requestAnimationFrame(() => layoutCropCanvas(true));
        }

        function layoutCropCanvas(resetRect) {
            const c = el.cropCanvas;
            const wrap = c.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            c.width = Math.max(1, Math.floor(wrap.width * dpr));
            c.height = Math.max(1, Math.floor(wrap.height * dpr));

            const iw = crop.img.naturalWidth, ih = crop.img.naturalHeight;
            const sx = c.width / iw, sy = c.height / ih;
            crop.displayScale = Math.min(sx, sy);

            const dw = iw * crop.displayScale, dh = ih * crop.displayScale;
            crop.offsetX = (c.width - dw) / 2;
            crop.offsetY = (c.height - dh) / 2;

            if (resetRect) {
                crop.rect.x = crop.offsetX; crop.rect.y = crop.offsetY;
                crop.rect.w = dw; crop.rect.h = dh;
            } else {
                crop.rect.x = clamp(crop.rect.x, crop.offsetX, crop.offsetX + dw - 10);
                crop.rect.y = clamp(crop.rect.y, crop.offsetY, crop.offsetY + dh - 10);
                crop.rect.w = clamp(crop.rect.w, 10, crop.offsetX + dw - crop.rect.x);
                crop.rect.h = clamp(crop.rect.h, 10, crop.offsetY + dh - crop.rect.y);
            }
            drawCrop();
        }

        function drawCrop() {
            const c = el.cropCanvas;
            const ctx = c.getContext('2d');
            ctx.clearRect(0, 0, c.width, c.height);
            ctx.fillStyle = 'rgba(0,0,0,.25)';
            ctx.fillRect(0, 0, c.width, c.height);

            const iw = crop.img.naturalWidth, ih = crop.img.naturalHeight;
            const dw = iw * crop.displayScale, dh = ih * crop.displayScale;
            ctx.drawImage(crop.img, crop.offsetX, crop.offsetY, dw, dh);

            ctx.save();
            ctx.fillStyle = 'rgba(0,0,0,.45)';
            ctx.beginPath();
            ctx.rect(0, 0, c.width, c.height);
            ctx.rect(crop.rect.x, crop.rect.y, crop.rect.w, crop.rect.h);
            ctx.fill('evenodd');
            ctx.restore();

            ctx.save();
            ctx.strokeStyle = 'rgba(122,162,255,.95)';
            ctx.lineWidth = 3;
            ctx.strokeRect(crop.rect.x, crop.rect.y, crop.rect.w, crop.rect.h);

            const hs = 12;
            const pts = [
                { k: 'nw', x: crop.rect.x, y: crop.rect.y },
                { k: 'ne', x: crop.rect.x + crop.rect.w, y: crop.rect.y },
                { k: 'sw', x: crop.rect.x, y: crop.rect.y + crop.rect.h },
                { k: 'se', x: crop.rect.x + crop.rect.w, y: crop.rect.y + crop.rect.h },
            ];
            ctx.fillStyle = 'rgba(122,162,255,.95)';
            for (const p of pts) { ctx.beginPath(); ctx.arc(p.x, p.y, hs / 2, 0, Math.PI * 2); ctx.fill(); }
            ctx.restore();
        }

        function cropHitTest(x, y) {
            const hs = 14;
            const corners = [
                { k: 'nw', x: crop.rect.x, y: crop.rect.y },
                { k: 'ne', x: crop.rect.x + crop.rect.w, y: crop.rect.y },
                { k: 'sw', x: crop.rect.x, y: crop.rect.y + crop.rect.h },
                { k: 'se', x: crop.rect.x + crop.rect.w, y: crop.rect.y + crop.rect.h },
            ];
            for (const c of corners) {
                const dx = x - c.x, dy = y - c.y;
                if (dx * dx + dy * dy <= hs * hs) return c.k;
            }
            if (x >= crop.rect.x && x <= crop.rect.x + crop.rect.w && y >= crop.rect.y && y <= crop.rect.y + crop.rect.h) return 'move';
            return null;
        }

        function onCropPointerDown(e) {
            const c = el.cropCanvas;
            c.setPointerCapture(e.pointerId);
            const dpr = window.devicePixelRatio || 1;
            const rect = c.getBoundingClientRect();
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;
            const mode = cropHitTest(x, y);
            if (!mode) return;
            crop.dragging = true; crop.dragMode = mode;
            crop.last.x = x; crop.last.y = y;
        }
        function onCropPointerMove(e) {
            if (!crop.dragging) return;
            const c = el.cropCanvas;
            const dpr = window.devicePixelRatio || 1;
            const rect = c.getBoundingClientRect();
            const x = (e.clientX - rect.left) * dpr;
            const y = (e.clientY - rect.top) * dpr;
            const dx = x - crop.last.x, dy = y - crop.last.y;
            crop.last.x = x; crop.last.y = y;

            const bounds = {
                x0: crop.offsetX,
                y0: crop.offsetY,
                x1: crop.offsetX + crop.img.naturalWidth * crop.displayScale,
                y1: crop.offsetY + crop.img.naturalHeight * crop.displayScale,
            };
            const minSize = 20;

            if (crop.dragMode === 'move') {
                crop.rect.x = clamp(crop.rect.x + dx, bounds.x0, bounds.x1 - crop.rect.w);
                crop.rect.y = clamp(crop.rect.y + dy, bounds.y0, bounds.y1 - crop.rect.h);
            } else {
                let x0 = crop.rect.x, y0 = crop.rect.y, x1 = crop.rect.x + crop.rect.w, y1 = crop.rect.y + crop.rect.h;
                if (crop.dragMode.includes('n')) y0 += dy;
                if (crop.dragMode.includes('w')) x0 += dx;
                if (crop.dragMode.includes('s')) y1 += dy;
                if (crop.dragMode.includes('e')) x1 += dx;

                x0 = clamp(x0, bounds.x0, x1 - minSize);
                y0 = clamp(y0, bounds.y0, y1 - minSize);
                x1 = clamp(x1, x0 + minSize, bounds.x1);
                y1 = clamp(y1, y0 + minSize, bounds.y1);

                crop.rect.x = x0; crop.rect.y = y0; crop.rect.w = x1 - x0; crop.rect.h = y1 - y0;
            }
            drawCrop();
        }
        function onCropPointerUp() { crop.dragging = false; crop.dragMode = null; }

        function applyCropToImage() {
            const sx = (crop.rect.x - crop.offsetX) / crop.displayScale;
            const sy = (crop.rect.y - crop.offsetY) / crop.displayScale;
            const sw = crop.rect.w / crop.displayScale;
            const sh = crop.rect.h / crop.displayScale;

            const out = document.createElement('canvas');
            out.width = Math.max(1, Math.floor(sw));
            out.height = Math.max(1, Math.floor(sh));
            const ctx = out.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(crop.img, sx, sy, sw, sh, 0, 0, out.width, out.height);

            const img = new Image();
            img.onload = () => { closeOverlay(el.cropOverlay); buildFromImage(img); };
            img.src = out.toDataURL('image/png');
        }

        /**********************
         * Image mode (quantize to nearest Mard) + maxColors limit
         **********************/
        function applyMaxColorsLimit(W, H, cells, usedColors, counts, maxN) {
            if (!maxN || maxN < 1) return { cells, usedColors, counts };
            if (usedColors.length <= maxN) return { cells, usedColors, counts };

            const keep = usedColors.slice(0, maxN);
            const keepLabs = keep.map(u => {
                const rgb = hexToRgb(u.hex);
                return { code: u.code, hex: u.hex, lab: rgbToLab(rgb.r, rgb.g, rgb.b) };
            });

            const mapOldToNew = new Map();
            for (let i = 0; i < keep.length; i++) {
                const oldIdx = usedColors.findIndex(u => u.code === keep[i].code);
                mapOldToNew.set(oldIdx, i);
            }

            const excludedMap = new Map();
            for (let oldIdx = 0; oldIdx < usedColors.length; oldIdx++) {
                if (mapOldToNew.has(oldIdx)) continue;
                const u = usedColors[oldIdx];
                const rgb = hexToRgb(u.hex);
                const lab = rgbToLab(rgb.r, rgb.g, rgb.b);
                let best = 0, bestD = Infinity;
                for (let i = 0; i < keepLabs.length; i++) {
                    const d = deltaE76(lab, keepLabs[i].lab);
                    if (d < bestD) { bestD = d; best = i; }
                }
                excludedMap.set(oldIdx, best);
            }

            const newCells = new Int16Array(W * H);
            newCells.fill(-1);
            const newCounts = new Map();
            for (const u of keep) { newCounts.set(u.code, 0); }

            for (let i = 0; i < cells.length; i++) {
                const old = cells[i];
                if (old < 0) { newCells[i] = -1; continue; }
                let ni = mapOldToNew.get(old);
                if (ni === undefined) ni = excludedMap.get(old);
                newCells[i] = ni;
                const code = keep[ni].code;
                newCounts.set(code, (newCounts.get(code) || 0) + 1);
            }

            const sortedKeep = [...newCounts.entries()].sort((a, b) => b[1] - a[1]).map(([code, count]) => {
                const u = keep.find(x => x.code === code);
                return { code, hex: u.hex, count };
            });

            const resortMap = new Map();
            sortedKeep.forEach((u, i) => resortMap.set(u.code, i));
            const finalCells = new Int16Array(W * H);
            finalCells.fill(-1);
            const finalCounts = new Map();
            for (const u of sortedKeep) { finalCounts.set(u.code, u.count); }

            for (let i = 0; i < newCells.length; i++) {
                const ci = newCells[i];
                if (ci < 0) continue;
                const code = keep[ci].code;
                finalCells[i] = resortMap.get(code);
            }

            const finalUsed = sortedKeep.map(u => ({ code: u.code, hex: u.hex }));
            return { cells: finalCells, usedColors: finalUsed, counts: finalCounts };
        }

        function buildFromImage(img) {
            rebuildPaletteMaps();

            let candidates = MARD_PALETTE.map(p => ({ name: p.name, color: p.color }));
            if (state.allowedSet) {
                candidates = candidates.filter(p => state.allowedSet.has(p.name));
            }
            const cand = candidates.map(p => {
                const rgb = hexToRgb(p.color);
                return { code: p.name, hex: p.color, lab: rgbToLab(rgb.r, rgb.g, rgb.b) };
            });
            if (cand.length === 0) throw new Error('å€™é€‰è‰²å¡ä¸ºç©ºï¼ˆæ£€æŸ¥ sehao é™åˆ¶ï¼‰');

            let W = parseInt(el.gridW.value, 10) || 52;
            let H = parseInt(el.gridH.value, 10) || 52;
            W = clamp(W, 1, MAX_GRID); H = clamp(H, 1, MAX_GRID);

            if (el.autoFit.checked) {
                const iw = img.naturalWidth, ih = img.naturalHeight;
                if (iw >= ih) {
                    H = clamp(Math.round(W * ih / iw), 1, MAX_GRID);
                } else {
                    W = clamp(Math.round(H * iw / ih), 1, MAX_GRID);
                }
                el.gridW.value = W; el.gridH.value = H;
            }

            const src = document.createElement('canvas');
            src.width = W; src.height = H;
            const sctx = src.getContext('2d', { willReadFrequently: true });
            sctx.drawImage(img, 0, 0, W, H);
            const data = sctx.getImageData(0, 0, W, H).data;

            const cache = new Map();
            function nearestCode(r, g, b) {
                const key = (r << 16) | (g << 8) | b;
                const hit = cache.get(key);
                if (hit) return hit;
                const lab = rgbToLab(r, g, b);
                let best = cand[0], bestD = Infinity;
                for (const c of cand) {
                    const d = deltaE76(lab, c.lab);
                    if (d < bestD) { bestD = d; best = c; }
                }
                cache.set(key, best);
                return best;
            }

            const codeGrid = new Array(W * H).fill('');
            const codeCount = new Map();
            for (let i = 0; i < W * H; i++) {
                const a = data[i * 4 + 3];
                if (a === 0) continue;
                const r = data[i * 4], g = data[i * 4 + 1], b = data[i * 4 + 2];
                const best = nearestCode(r, g, b);
                codeGrid[i] = best.code;
                codeCount.set(best.code, (codeCount.get(best.code) || 0) + 1);
            }

            const sorted = [...codeCount.entries()].sort((a, b) => b[1] - a[1]);
            let usedColors = sorted.map(([code, count]) => ({ code, hex: state.codeToHex.get(code), count }));

            const idxMap = new Map();
            usedColors.forEach((u, i) => idxMap.set(u.code, i));

            let cells = new Int16Array(W * H);
            cells.fill(-1);
            for (let i = 0; i < W * H; i++) {
                const code = codeGrid[i];
                if (!code) continue;
                const idx = idxMap.get(code);
                if (idx === undefined) continue;
                cells[i] = idx;
            }

            const maxN = clamp(parseInt(el.maxColors.value || '0', 10) || 0, 1, 256);
            if (usedColors.length > maxN) {
                const counts = new Map(sorted);
                const limited = applyMaxColorsLimit(W, H, cells, usedColors.map(u => ({ code: u.code, hex: u.hex })), counts, maxN);
                cells = limited.cells;
                usedColors = limited.usedColors.map(u => ({ code: u.code, hex: u.hex, count: limited.counts.get(u.code) || 0 }));
                state.usedCounts = limited.counts;
            } else {
                state.usedCounts = new Map(sorted);
            }

            state.gridW = W; state.gridH = H;
            state.cells = cells;
            state.usedColors = usedColors.map(u => ({ code: u.code, hex: u.hex }));

            state.done.clear(); state.doneHistory.length = 0;
            state.history.length = 0; state.activeTarget = null;
            state.activeCode = state.usedColors[0]?.code || null;
            state.isReady = true;
            syncUIAfterBuild();
            fitToScreen();
        }

        /**********************
         * UI sync + color lists
         **********************/
        function syncUIAfterBuild() {
            state.showCode = el.showCode.checked;
            el.statusPill.textContent = 'å·²å¯¼å…¥';
            el.metaGrid.textContent = `ç½‘æ ¼ï¼š${state.gridW} Ã— ${state.gridH}`;
            updateFabOnlyText();
            refreshColorLists();
            updateMeta();
            requestDraw();
        }

        function refreshColorLists() {
            const q = (el.colorSearch.value || '').trim().toUpperCase();
            el.colorList.innerHTML = '';
            for (const u of state.usedColors) {
                if (q && !u.code.toUpperCase().includes(q)) continue;
                const count = state.usedCounts.get(u.code) || 0;
                const item = document.createElement('div');
                item.className = 'colorItem' + (u.code === state.activeCode ? ' active' : '');
                item.innerHTML = `
          <div class="ciLeft">
            <div class="sw" style="background:#${u.hex}"></div>
            <div class="ciText">
              <b>${u.code}</b>
              <small>#${u.hex}</small>
            </div>
          </div>
          <div class="ciRight">${count} é¢—</div>
        `;
                item.addEventListener('click', () => setActiveColor(u.code));
                el.colorList.appendChild(item);
            }
            refreshPickList();
            refreshEditList();
            refreshBulkList();
            refreshExportList();
        }

        function refreshPickList() {
            const q = (el.pickSearch.value || '').trim().toUpperCase();
            el.pickList.innerHTML = '';
            for (const u of state.usedColors) {
                if (q && !u.code.toUpperCase().includes(q)) continue;
                const count = state.usedCounts.get(u.code) || 0;
                const item = document.createElement('div');
                item.className = 'colorItem' + (u.code === state.activeCode ? ' active' : '');
                item.innerHTML = `
          <div class="ciLeft">
            <div class="sw" style="background:#${u.hex}"></div>
            <div class="ciText">
              <b>${u.code}</b>
              <small>#${u.hex}</small>
            </div>
          </div>
          <div class="ciRight">${count} é¢—</div>
        `;
                item.addEventListener('click', () => { setActiveColor(u.code); closeOverlay(el.pickOverlay); });
                el.pickList.appendChild(item);
            }
        }

        function refreshEditList() {
            const q = (el.editSearch.value || '').trim().toUpperCase();
            el.editList.innerHTML = '';
            for (const p of MARD_PALETTE) {
                if (state.allowedSet && !state.allowedSet.has(p.name)) continue;
                if (q && !p.name.toUpperCase().includes(q)) continue;
                const item = document.createElement('div');
                item.className = 'colorItem';
                item.innerHTML = `
          <div class="ciLeft">
            <div class="sw" style="background:#${p.color}"></div>
            <div class="ciText">
              <b>${p.name}</b>
              <small>#${p.color}</small>
            </div>
          </div>
          <div class="ciRight">ç‚¹å‡»æ›¿æ¢</div>
        `;
                item.addEventListener('click', () => { applyEditColorToPickedCell(p.name, p.color); closeOverlay(el.editOverlay); });
                el.editList.appendChild(item);
            }
        }

        function setActiveColor(code) {
            state.activeCode = code;
            state.activeTarget = null;
            state.history.length = 0;
            refreshColorLists();
            updateMeta();
            requestDraw();
        }

        /**********************
         * Next / Prev / Done / Undo
         **********************/
        function idxOfCode(code) { return state.usedColors.findIndex(u => u.code === code); }

        function remainForCode(code) {
            if (!state.isReady || !code) return 0;
            const idx = idxOfCode(code);
            if (idx < 0) return 0;
            let remain = 0;
            for (let i = 0; i < state.cells.length; i++) {
                if (state.cells[i] === idx && !state.done.has(i)) remain++;
            }
            return remain;
        }

        function pickNextColorWithRemain() {
            if (!state.isReady || state.usedColors.length === 0) return null;
            const start = Math.max(0, idxOfCode(state.activeCode));
            for (let step = 1; step <= state.usedColors.length; step++) {
                const i = (start + step) % state.usedColors.length;
                const code = state.usedColors[i].code;
                if (remainForCode(code) > 0) return code;
            }
            return null;
        }

        function advanceToNextColorIfNeeded() {
            if (!state.activeCode) return false;
            if (remainForCode(state.activeCode) > 0) return false;

            const next = pickNextColorWithRemain();
            if (!next) {
                state.activeTarget = null;
                state.history.length = 0;
                el.statusPill.textContent = 'å…¨éƒ¨å®Œæˆ ğŸ‰';
                updateMeta();
                requestDraw();
                return true;
            }
            state.activeCode = next;
            state.activeTarget = null;
            state.history.length = 0;
            el.statusPill.textContent = `å·²åˆ‡æ¢é¢œè‰²ï¼š${next}`;
            refreshColorLists();
            updateMeta();
            requestDraw();
            return true;
        }

        function findNextCell() {
            if (!state.isReady || !state.activeCode) return null;
            const W = state.gridW, H = state.gridH;
            const idx = idxOfCode(state.activeCode);
            if (idx < 0) return null;

            if (state.activeTarget) {
                const k = state.activeTarget.y * W + state.activeTarget.x;
                if (!state.done.has(k) && state.cells[k] === idx) return state.activeTarget;
            }

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const k = y * W + x;
                    if (state.done.has(k)) continue;
                    if (state.cells[k] === idx) return { x, y };
                }
            }
            return null;
        }

        function nextCell() {
            if (!state.isReady) return;

            advanceToNextColorIfNeeded();

            let t = findNextCell();
            if (!t) {
                if (advanceToNextColorIfNeeded()) {
                    t = findNextCell();
                }
                if (!t) {
                    el.statusPill.textContent = 'å…¨éƒ¨å®Œæˆ ğŸ‰';
                    return;
                }
            }

            if (state.activeTarget) {
                state.history.push({ ...state.activeTarget });
                if (state.history.length > 2000) state.history.shift();
            }
            state.activeTarget = t;
            updateMeta();
            requestDraw();
        }

        function prevCell() {
            if (state.history.length === 0) return;
            state.activeTarget = state.history.pop();
            updateMeta();
            requestDraw();
        }

        function markDoneCurrent() {
            if (!state.activeTarget) return;
            const W = state.gridW;
            const k = state.activeTarget.y * W + state.activeTarget.x;
            if (!state.done.has(k)) {
                state.done.add(k);
                state.doneHistory.push(k);
                if (state.doneHistory.length > 200000) state.doneHistory.shift();
            }
            el.statusPill.textContent = 'å·²æ ‡è®°å®Œæˆ';
            updateMeta();
            requestDraw();
            nextCell();
        }

        function undoDone() {
            if (!state.isReady) return;
            if (state.doneHistory.length === 0) return;

            const W = state.gridW;
            const k = state.doneHistory.pop();
            state.done.delete(k);

            const x = k % W;
            const y = Math.floor(k / W);
            state.activeTarget = { x, y };
            state.lastPickedCell = { x, y };
            el.statusPill.textContent = 'å·²æ’¤é”€ä¸Šä¸€é¢—';
            updateMeta();
            requestDraw();
        }

        /**********************
         * ä¸€é”®å®ŒæˆæŒ‡å®šè‰²å·
         **********************/
        function markDoneAllForColor(code) {
            if (!state.isReady || !code) return;
            const idx = idxOfCode(code);
            if (idx < 0) return;

            let added = 0;
            for (let i = 0; i < state.cells.length; i++) {
                if (state.cells[i] === idx && !state.done.has(i)) {
                    state.done.add(i);
                    state.doneHistory.push(i);
                    added++;
                }
            }
            while (state.doneHistory.length > 200000) state.doneHistory.shift();

            state.activeTarget = null;
            state.history.length = 0;

            el.statusPill.textContent = added ? `å·²ä¸€é”®å®Œæˆ ${code}ï¼ˆ+${added}ï¼‰` : `é¢œè‰² ${code} å·²å…¨éƒ¨å®Œæˆ`;
            refreshColorLists();
            updateMeta();
            requestDraw();

            advanceToNextColorIfNeeded();
            nextCell();
        }

        function updateMeta() {
            el.metaGrid.textContent = state.isReady ? `ç½‘æ ¼ï¼š${state.gridW} Ã— ${state.gridH}` : 'ç½‘æ ¼ï¼šâ€”';
            el.metaColor.textContent = state.activeCode ? `å½“å‰è‰²ï¼š${state.activeCode}` : 'å½“å‰è‰²ï¼šâ€”';

            if (!state.isReady || !state.activeCode) {
                el.metaTodo.textContent = 'å‰©ä½™ï¼šâ€”';
                el.posPill.textContent = 'â€”';
                return;
            }

            const remain = remainForCode(state.activeCode);
            el.metaTodo.textContent = `å‰©ä½™ï¼š${remain}`;
            if (state.activeTarget) {
                el.posPill.textContent = `(${state.activeTarget.x + 1}, ${state.activeTarget.y + 1})`;
            } else {
                el.posPill.textContent = 'â€”';
            }
        }

        /**********************
         * Manual edit cell
         **********************/
        function openEditOverlay() {
            if (!state.lastPickedCell) {
                el.editInfo.textContent = 'å…ˆç‚¹é€‰ä¸€ä¸ªæ ¼å­';
            } else {
                el.editInfo.textContent = `å½“å‰æ ¼ï¼š(${state.lastPickedCell.x + 1}, ${state.lastPickedCell.y + 1})`;
            }
            el.editSearch.value = '';
            refreshEditList();
            openOverlay(el.editOverlay);
        }

        function applyEditColorToPickedCell(code, hex) {
            if (!state.lastPickedCell || !state.isReady) return;
            const x = state.lastPickedCell.x, y = state.lastPickedCell.y;
            const k = y * state.gridW + x;

            let idx = state.usedColors.findIndex(u => u.code === code);
            if (idx < 0) {
                state.usedColors.push({ code, hex });
                idx = state.usedColors.length - 1;
                state.usedCounts.set(code, 0);
            }

            const oldIdx = state.cells[k];
            if (oldIdx >= 0) {
                const oldCode = state.usedColors[oldIdx].code;
                state.usedCounts.set(oldCode, Math.max(0, (state.usedCounts.get(oldCode) || 0) - 1));
            }
            state.cells[k] = idx;
            state.usedCounts.set(code, (state.usedCounts.get(code) || 0) + 1);

            refreshColorLists();
            updateMeta();
            requestDraw();
        }

        /**********************
         * Canvas rendering
         **********************/
        const ctx = el.view.getContext('2d');
        let rafId = null;
        let animT = 0;

        function resizeViewCanvas() {
            const rect = el.view.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            el.view.width = Math.max(1, Math.floor(rect.width * dpr));
            el.view.height = Math.max(1, Math.floor(rect.height * dpr));
            requestDraw();
        }

        window.addEventListener('resize', () => {
            resizeViewCanvas();
            if (el.cropOverlay.style.display === 'flex') layoutCropCanvas(false);
        });

        function fitToScreen() {
            if (!state.isReady) return;
            const W = state.gridW, H = state.gridH;
            const pad = 24;
            const cw = el.view.width, ch = el.view.height;
            const zx = (cw - pad * 2) / (W * view.baseCell);
            const zy = (ch - pad * 2) / (H * view.baseCell);
            view.zoom = Math.max(0.2, Math.min(zx, zy));
            const worldW = W * view.baseCell * view.zoom;
            const worldH = H * view.baseCell * view.zoom;
            view.panX = (cw - worldW) / 2;
            view.panY = (ch - worldH) / 2;
            requestDraw();
        }

        function resetView() { view.zoom = 1; view.panX = 0; view.panY = 0; fitToScreen(); }

        function requestDraw() {
            if (rafId) return;
            rafId = requestAnimationFrame(draw);
        }

        function draw() {
            rafId = null;
            animT += 1 / 60;

            const cw = el.view.width, ch = el.view.height;
            ctx.clearRect(0, 0, cw, ch);
            ctx.fillStyle = 'rgba(0,0,0,.10)';
            ctx.fillRect(0, 0, cw, ch);

            if (!state.isReady) {
                ctx.save();
                ctx.fillStyle = 'rgba(255,255,255,.70)';
                ctx.font = `${Math.round(14 * (window.devicePixelRatio || 1))}px system-ui`;
                ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText('å¯¼å…¥å›¾çº¸å›¾ç‰‡æˆ– CSV åå¼€å§‹', cw / 2, ch / 2);
                ctx.restore();
                return;
            }

            const W = state.gridW, H = state.gridH;
            const cell = view.baseCell, z = view.zoom;

            const x0 = Math.floor((-view.panX) / (cell * z)) - 1;
            const y0 = Math.floor((-view.panY) / (cell * z)) - 1;
            const x1 = Math.ceil((cw - view.panX) / (cell * z)) + 1;
            const y1 = Math.ceil((ch - view.panY) / (cell * z)) + 1;

            const vx0 = clamp(x0, 0, W), vy0 = clamp(y0, 0, H), vx1 = clamp(x1, 0, W), vy1 = clamp(y1, 0, H);

            const activeIdx = state.activeCode ? idxOfCode(state.activeCode) : -1;
            const showText = state.showCode && z >= 0.65;

            ctx.save();
            ctx.translate(view.panX, view.panY);
            ctx.scale(z, z);
            ctx.lineWidth = 1 / z;
            ctx.strokeStyle = 'rgba(0,0,0,.35)';

            for (let y = vy0; y < vy1; y++) {
                for (let x = vx0; x < vx1; x++) {
                    const k = y * W + x;
                    const idx = state.cells[k];

                    let fill = '111318';
                    if (idx >= 0) fill = state.usedColors[idx].hex;

                    let alpha = 1;
                    if (state.onlyActiveColor && activeIdx >= 0) {
                        if (idx !== activeIdx) alpha = 0.18;
                    }

                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = '#' + fill;
                    ctx.fillRect(x * cell, y * cell, cell, cell);
                    ctx.globalAlpha = 1;

                    ctx.strokeRect(x * cell, y * cell, cell, cell);

                    if (state.done.has(k)) {
                        ctx.save();
                        ctx.globalAlpha = 0.60;
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x * cell, y * cell, cell, cell);

                        ctx.globalAlpha = 0.92;
                        ctx.strokeStyle = 'rgba(255,255,255,.60)';
                        ctx.lineWidth = 2.4 / z;
                        ctx.beginPath();
                        ctx.moveTo(x * cell + 2, y * cell + 2);
                        ctx.lineTo(x * cell + cell - 2, y * cell + cell - 2);
                        ctx.moveTo(x * cell + cell - 2, y * cell + 2);
                        ctx.lineTo(x * cell + 2, y * cell + cell - 2);
                        ctx.stroke();
                        ctx.restore();
                    }
                }
            }

            if (state.activeTarget) {
                const { x, y } = state.activeTarget;
                const px = x * cell, py = y * cell;
                const pulse = 0.55 + 0.45 * Math.sin(animT * 6.0);

                ctx.save();
                ctx.globalAlpha = 0.10 + 0.08 * pulse;
                ctx.fillStyle = 'rgba(255,234,0,1)';
                ctx.fillRect(px, py, cell, cell);

                ctx.globalAlpha = 0.98;
                ctx.lineWidth = (4.8 + 2.8 * pulse) / z;
                ctx.strokeStyle = 'rgba(255,234,0,.95)';
                ctx.strokeRect(px + 1.2, py + 1.2, cell - 2.4, cell - 2.4);

                ctx.globalAlpha = 0.80;
                ctx.lineWidth = 1.4 / z;
                ctx.strokeStyle = 'rgba(255,255,255,.70)';
                ctx.strokeRect(px + 5, py + 5, cell - 10, cell - 10);
                ctx.restore();
            }

            if (showText) {
                ctx.save();
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.font = `${Math.max(9, Math.min(15, Math.floor(cell * 0.46)))}px ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace`;

                for (let y = vy0; y < vy1; y++) {
                    for (let x = vx0; x < vx1; x++) {
                        const k = y * W + x;
                        const idx = state.cells[k];
                        if (idx < 0) continue;
                        const code = state.usedColors[idx].code;
                        const rgb = hexToRgb(state.usedColors[idx].hex);
                        const lum = (0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b);
                        ctx.fillStyle = lum > 140 ? 'rgba(0,0,0,.85)' : 'rgba(255,255,255,.92)';
                        ctx.fillText(code, x * cell + cell / 2, y * cell + cell / 2);
                    }
                }
                ctx.restore();
            }

            ctx.restore();

            if (state.activeTarget) requestDraw();
        }

        /**********************
         * Canvas interactions (pan/zoom + tap select)
         **********************/
        const pointer = { down: false, moved: false, startX: 0, startY: 0, pan0X: 0, pan0Y: 0, t0: 0, touches: new Map(), pinch0: null };

        function canvasToWorld(sx, sy) {
            const z = view.zoom, cell = view.baseCell;
            const wx = (sx - view.panX) / z;
            const wy = (sy - view.panY) / z;
            return { x: Math.floor(wx / cell), y: Math.floor(wy / cell) };
        }

        function onPointerDown(e) {
            el.view.setPointerCapture(e.pointerId);
            const rect = el.view.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const sx = (e.clientX - rect.left) * dpr;
            const sy = (e.clientY - rect.top) * dpr;

            pointer.touches.set(e.pointerId, { x: sx, y: sy });
            if (pointer.touches.size === 2) {
                const pts = [...pointer.touches.values()];
                pointer.pinch0 = {
                    dist: Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y),
                    zoom: view.zoom, panX: view.panX, panY: view.panY,
                    midX: (pts[0].x + pts[1].x) / 2,
                    midY: (pts[0].y + pts[1].y) / 2
                };
                return;
            }

            pointer.down = true; pointer.moved = false;
            pointer.startX = sx; pointer.startY = sy;
            pointer.pan0X = view.panX; pointer.pan0Y = view.panY;
            pointer.t0 = performance.now();
        }

        function onPointerMove(e) {
            if (!pointer.touches.has(e.pointerId)) return;
            const rect = el.view.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const sx = (e.clientX - rect.left) * dpr;
            const sy = (e.clientY - rect.top) * dpr;
            pointer.touches.set(e.pointerId, { x: sx, y: sy });

            if (pointer.touches.size === 2 && pointer.pinch0) {
                const pts = [...pointer.touches.values()];
                const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
                const midX = (pts[0].x + pts[1].x) / 2;
                const midY = (pts[0].y + pts[1].y) / 2;

                const scale = dist / pointer.pinch0.dist;
                const z0 = pointer.pinch0.zoom;
                const z1 = clamp(z0 * scale, 0.2, 10);

                const wx = (pointer.pinch0.midX - pointer.pinch0.panX) / z0;
                const wy = (pointer.pinch0.midY - pointer.pinch0.panY) / z0;

                view.zoom = z1;
                view.panX = midX - wx * z1;
                view.panY = midY - wy * z1;

                requestDraw();
                return;
            }

            if (!pointer.down) return;
            const dx = sx - pointer.startX, dy = sy - pointer.startY;
            if (Math.abs(dx) + Math.abs(dy) > 4) pointer.moved = true;
            view.panX = pointer.pan0X + dx;
            view.panY = pointer.pan0Y + dy;
            requestDraw();
        }

        function onPointerUp(e) {
            pointer.touches.delete(e.pointerId);
            if (pointer.touches.size < 2) pointer.pinch0 = null;
            if (!pointer.down) return;
            pointer.down = false;

            const rect = el.view.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const sx = (e.clientX - rect.left) * dpr;
            const sy = (e.clientY - rect.top) * dpr;
            const dt = performance.now() - pointer.t0;

            if (!pointer.moved && dt < 300 && state.isReady) {
                const hit = canvasToWorld(sx, sy);
                if (hit.x >= 0 && hit.x < state.gridW && hit.y >= 0 && hit.y < state.gridH) {
                    state.lastPickedCell = { x: hit.x, y: hit.y };
                    state.activeTarget = { x: hit.x, y: hit.y };
                    updateMeta();
                    requestDraw();
                }
            }
        }

        function onWheel(e) {
            if (!state.isReady) return;
            e.preventDefault();
            const rect = el.view.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            const sx = (e.clientX - rect.left) * dpr;
            const sy = (e.clientY - rect.top) * dpr;

            const zoomFactor = Math.exp(-e.deltaY * 0.0012);
            const z0 = view.zoom;
            const z1 = clamp(z0 * zoomFactor, 0.2, 10);

            const wx = (sx - view.panX) / z0;
            const wy = (sy - view.panY) / z0;

            view.zoom = z1;
            view.panX = sx - wx * z1;
            view.panY = sy - wy * z1;
            requestDraw();
        }

        el.view.addEventListener('pointerdown', onPointerDown);
        el.view.addEventListener('pointermove', onPointerMove);
        el.view.addEventListener('pointerup', onPointerUp);
        el.view.addEventListener('pointercancel', onPointerUp);
        el.view.addEventListener('wheel', onWheel, { passive: false });

        /**********************
         * Bulk overlay list
         **********************/
        function refreshBulkList() {
            if (!state.isReady) { el.bulkList.innerHTML = ''; return; }
            const q = (el.bulkSearch.value || '').trim().toUpperCase();
            el.bulkList.innerHTML = '';

            const arr = [...state.usedColors].slice().sort((a, b) => (state.usedCounts.get(b.code) || 0) - (state.usedCounts.get(a.code) || 0));

            for (const u of arr) {
                if (q && !u.code.toUpperCase().includes(q)) continue;
                const total = state.usedCounts.get(u.code) || 0;
                const remain = remainForCode(u.code);
                const item = document.createElement('div');
                item.className = 'colorItem' + (u.code === state.activeCode ? ' active' : '');
                item.innerHTML = `
          <div class="ciLeft">
            <div class="sw" style="background:#${u.hex}"></div>
            <div class="ciText">
              <b>${u.code}</b>
              <small>#${u.hex}</small>
            </div>
          </div>
          <div class="ciRight">${remain}/${total} å‰©ä½™</div>
        `;
                item.addEventListener('click', () => {
                    closeOverlay(el.bulkOverlay);
                    markDoneAllForColor(u.code);
                });
                el.bulkList.appendChild(item);
            }
        }

        function openBulkOverlay() {
            if (!state.isReady) { alert('è¯·å…ˆå¯¼å…¥å›¾çº¸'); return; }
            el.bulkSearch.value = '';
            refreshBulkList();
            openOverlay(el.bulkOverlay);
        }

        /**********************
         * Export
         **********************/
        const exportState = {
            includeSet: new Set(),
        };

        function openExportOverlay() {
            if (!state.isReady) { alert('è¯·å…ˆå¯¼å…¥å›¾çº¸'); return; }
            exportState.includeSet = new Set(state.usedColors.map(u => u.code));
            el.exportSearch.value = '';
            el.exportBlankExcluded.checked = true;
            refreshExportList();
            openOverlay(el.exportOverlay);
        }

        function refreshExportList() {
            if (!el.exportOverlay) return;
            if (!state.isReady) { el.exportList.innerHTML = ''; return; }

            const q = (el.exportSearch.value || '').trim().toUpperCase();
            el.exportList.innerHTML = '';

            const arr = [...state.usedColors].slice().sort((a, b) => (state.usedCounts.get(b.code) || 0) - (state.usedCounts.get(a.code) || 0));

            for (const u of arr) {
                if (q && !u.code.toUpperCase().includes(q)) continue;

                const total = state.usedCounts.get(u.code) || 0;
                const remain = remainForCode(u.code);
                const checked = exportState.includeSet.has(u.code);

                const item = document.createElement('div');
                item.className = 'colorItem';
                item.style.cursor = 'default';
                item.innerHTML = `
          <div class="checkRow">
            <input type="checkbox" ${checked ? 'checked' : ''} />
            <div class="ciLeft" style="flex:1">
              <div class="sw" style="background:#${u.hex}"></div>
              <div class="ciText">
                <b>${u.code}</b>
                <small>#${u.hex}</small>
              </div>
            </div>
            <div class="ciRight">${remain}/${total} å‰©ä½™</div>
          </div>
        `;
                const cb = item.querySelector('input[type="checkbox"]');
                cb.addEventListener('change', () => {
                    if (cb.checked) exportState.includeSet.add(u.code);
                    else exportState.includeSet.delete(u.code);
                });
                el.exportList.appendChild(item);
            }
        }

        function calcExportStats(includeSet) {
            const total = new Map();
            const done = new Map();

            for (let i = 0; i < state.cells.length; i++) {
                const idx = state.cells[i];
                if (idx < 0) continue;
                const code = state.usedColors[idx].code;
                if (!includeSet.has(code)) continue;

                total.set(code, (total.get(code) || 0) + 1);
                if (state.done.has(i)) done.set(code, (done.get(code) || 0) + 1);
            }

            const rows = [];
            for (const [code, t] of total.entries()) {
                const d = done.get(code) || 0;
                const hex = state.codeToHex.get(code) || state.usedColors.find(x => x.code === code)?.hex || '000000';
                rows.push({ code, hex, total: t, done: d, remain: Math.max(0, t - d) });
            }
            rows.sort((a, b) => b.total - a.total);
            return rows;
        }

        function exportGridCSV() {
            const includeSet = exportState.includeSet;
            const blankExcluded = el.exportBlankExcluded.checked;

            const W = state.gridW, H = state.gridH;
            const lines = [];
            for (let y = 0; y < H; y++) {
                const row = [];
                for (let x = 0; x < W; x++) {
                    const k = y * W + x;
                    const idx = state.cells[k];
                    if (idx < 0) { row.push(''); continue; }
                    const code = state.usedColors[idx].code;
                    if (includeSet.has(code)) row.push(code);
                    else row.push(blankExcluded ? '' : code);
                }
                lines.push(row.join(','));
            }
            downloadText(`mard_grid_${timeStamp()}.csv`, lines.join('\n'), 'text/csv;charset=utf-8');
        }

        function exportStatsCSV() {
            const includeSet = exportState.includeSet;
            const rows = calcExportStats(includeSet);
            let csv = 'code,hex,total,done,remain\n';
            for (const r of rows) {
                csv += `${r.code},#${r.hex},${r.total},${r.done},${r.remain}\n`;
            }
            downloadText(`mard_stats_${timeStamp()}.csv`, csv, 'text/csv;charset=utf-8');
        }

        function exportAsJSON() {
            const includeSet = exportState.includeSet;
            const blankExcluded = el.exportBlankExcluded.checked;
            const W = state.gridW, H = state.gridH;

            const cells = [];
            for (let y = 0; y < H; y++) {
                const row = [];
                for (let x = 0; x < W; x++) {
                    const k = y * W + x;
                    const idx = state.cells[k];
                    if (idx < 0) { row.push(''); continue; }
                    const code = state.usedColors[idx].code;
                    if (includeSet.has(code)) row.push(code);
                    else row.push(blankExcluded ? '' : code);
                }
                cells.push(row);
            }

            const stats = calcExportStats(includeSet);
            const excluded = state.usedColors.map(u => u.code).filter(c => !includeSet.has(c));

            const out = {
                app: 'mard-grid-helper',
                exportedAt: new Date().toISOString(),
                grid: { W, H },
                palette: 'mard',
                includeCodes: [...includeSet],
                excludedCodes: excluded,
                blankExcludedInGrid: !!blankExcluded,
                stats,
                cells,
                done: [...state.done],
            };

            downloadText(`mard_export_${timeStamp()}.json`, JSON.stringify(out, null, 2), 'application/json;charset=utf-8');
        }

        function exportAsPNG() {
            const includeSet = exportState.includeSet;
            const blankExcluded = el.exportBlankExcluded.checked;
            const W = state.gridW, H = state.gridH;

            const cell = 20;
            const out = document.createElement('canvas');
            out.width = W * cell;
            out.height = H * cell;
            const g = out.getContext('2d');

            g.clearRect(0, 0, out.width, out.height);
            g.fillStyle = '#0b0c10';
            g.fillRect(0, 0, out.width, out.height);

            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W; x++) {
                    const k = y * W + x;
                    const idx = state.cells[k];
                    if (idx < 0) continue;
                    const code = state.usedColors[idx].code;

                    if (!includeSet.has(code) && blankExcluded) {
                        g.fillStyle = 'rgba(255,255,255,0.04)';
                        g.fillRect(x * cell, y * cell, cell, cell);
                        continue;
                    }

                    const hex = state.usedColors[idx].hex;
                    g.fillStyle = '#' + hex;
                    g.fillRect(x * cell, y * cell, cell, cell);

                    if (state.done.has(k)) {
                        g.fillStyle = 'rgba(0,0,0,0.42)';
                        g.fillRect(x * cell, y * cell, cell, cell);
                    }
                }
            }

            g.strokeStyle = 'rgba(0,0,0,0.35)';
            g.lineWidth = 1;
            for (let x = 0; x <= W; x++) {
                g.beginPath();
                g.moveTo(x * cell + 0.5, 0);
                g.lineTo(x * cell + 0.5, H * cell);
                g.stroke();
            }
            for (let y = 0; y <= H; y++) {
                g.beginPath();
                g.moveTo(0, y * cell + 0.5);
                g.lineTo(W * cell, y * cell + 0.5);
                g.stroke();
            }

            out.toBlob((blob) => {
                if (!blob) { alert('å¯¼å‡º PNG å¤±è´¥'); return; }
                downloadBlob(`mard_grid_${timeStamp()}.png`, blob);
            }, 'image/png');
        }

        /**********************
         * Wire UI events
         **********************/
        el.colorSearch.addEventListener('input', refreshColorLists);
        el.pickSearch.addEventListener('input', refreshPickList);
        el.editSearch.addEventListener('input', refreshEditList);
        el.bulkSearch.addEventListener('input', refreshBulkList);
        el.exportSearch.addEventListener('input', refreshExportList);

        el.showCode.addEventListener('change', () => { state.showCode = el.showCode.checked; requestDraw() });

        el.limitSehao.addEventListener('change', () => {
            rebuildPaletteMaps();
            el.statusPill.textContent = 'å·²åˆ‡æ¢è‰²å·é™åˆ¶ï¼ˆéœ€é‡æ–°å¯¼å…¥ï¼‰';
        });

        el.fitBtn.addEventListener('click', fitToScreen);
        el.resetViewBtn.addEventListener('click', resetView);
        el.zoomInBtn.addEventListener('click', () => { view.zoom = clamp(view.zoom * 1.15, 0.2, 10); requestDraw() });
        el.zoomOutBtn.addEventListener('click', () => { view.zoom = clamp(view.zoom / 1.15, 0.2, 10); requestDraw() });

        el.nextBtn.addEventListener('click', nextCell);
        el.prevBtn.addEventListener('click', prevCell);
        el.doneBtn.addEventListener('click', markDoneCurrent);
        el.undoBtn.addEventListener('click', undoDone);

        el.editCellBtn.addEventListener('click', openEditOverlay);
        el.editClose.addEventListener('click', () => closeOverlay(el.editOverlay));

        el.cropClose.addEventListener('click', () => closeOverlay(el.cropOverlay));
        el.cropSkip.addEventListener('click', () => { closeOverlay(el.cropOverlay); buildFromImage(crop.img); });
        el.cropApply.addEventListener('click', applyCropToImage);
        el.cropCanvas.addEventListener('pointerdown', onCropPointerDown);
        el.cropCanvas.addEventListener('pointermove', onCropPointerMove);
        el.cropCanvas.addEventListener('pointerup', onCropPointerUp);
        el.cropCanvas.addEventListener('pointercancel', onCropPointerUp);

        el.pickClose.addEventListener('click', () => closeOverlay(el.pickOverlay));
        el.bulkClose.addEventListener('click', () => closeOverlay(el.bulkOverlay));

        el.bulkBtn.addEventListener('click', openBulkOverlay);
        el.exportBtn.addEventListener('click', openExportOverlay);

        el.exportClose.addEventListener('click', () => closeOverlay(el.exportOverlay));
        el.exportSelectAll.addEventListener('click', () => {
            exportState.includeSet = new Set(state.usedColors.map(u => u.code));
            refreshExportList();
        });
        el.exportSelectNone.addEventListener('click', () => {
            exportState.includeSet = new Set();
            refreshExportList();
        });

        el.exportGridCSV.addEventListener('click', exportGridCSV);
        el.exportStatsCSV.addEventListener('click', exportStatsCSV);
        el.exportJSON.addEventListener('click', exportAsJSON);
        el.exportPNG.addEventListener('click', exportAsPNG);

        // FAB æŠ˜å /å±•å¼€ï¼ˆé»˜è®¤å±•å¼€ï¼Œå¯è®°å¿†ï¼‰
        function setFabCollapsed(collapsed) {
            el.fab.classList.toggle('collapsed', !!collapsed);
            localStorage.setItem('fab_collapsed', collapsed ? '1' : '0');
        }
        const fabCollapsed = localStorage.getItem('fab_collapsed') === '1';
        setFabCollapsed(fabCollapsed);

        el.fabMain.addEventListener('click', () => {
            setFabCollapsed(!el.fab.classList.contains('collapsed'));
        });

        // âœ… FABï¼šé¢æ¿æ˜¾ç¤º/éšè—
        el.fabPanelToggle.addEventListener('click', () => {
            const hidden = document.body.classList.contains('panelHidden');
            setPanelHidden(!hidden);
        });

        // âœ… FABï¼šåªçœ‹å½“å‰è‰²
        el.fabOnly.addEventListener('click', toggleOnlyActiveColor);

        // âœ… FABï¼šå½“å‰æ ¼å±…ä¸­
        el.fabCenter.addEventListener('click', centerOnCurrentTarget);

        // FAB è¡Œä¸º
        el.fabPick.addEventListener('click', () => { if (!state.isReady) return alert('è¯·å…ˆå¯¼å…¥å›¾çº¸'); openOverlay(el.pickOverlay); });
        el.fabFit.addEventListener('click', fitToScreen);
        el.fabPrev.addEventListener('click', prevCell);
        el.fabNext.addEventListener('click', nextCell);
        el.fabDone.addEventListener('click', markDoneCurrent);
        el.fabUndo.addEventListener('click', undoDone);
        el.fabBulk.addEventListener('click', openBulkOverlay);
        el.fabExport.addEventListener('click', openExportOverlay);

        window.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeOverlay(el.cropOverlay);
                closeOverlay(el.pickOverlay);
                closeOverlay(el.editOverlay);
                closeOverlay(el.bulkOverlay);
                closeOverlay(el.exportOverlay);
            }
            if (e.key === 'n' || e.key === 'N') nextCell();
            if (e.key === 'p' || e.key === 'P') prevCell();
            if (e.key === 'd' || e.key === 'D') markDoneCurrent();
            if (e.key === 'u' || e.key === 'U') undoDone();
        });

        /**********************
         * Import handlers
         **********************/
        el.allowedFile.addEventListener('change', async () => {
            const f = el.allowedFile.files?.[0];
            if (!f) return;
            const text = await f.text();
            try {
                rebuildPaletteMaps();
                state.allowedList = parseAllowedCodesCSV(text);
                rebuildPaletteMaps();
                el.statusPill.textContent = `å·²è½½å…¥ sehaoï¼š${state.allowedList.length} ä¸ªè‰²å·ï¼ˆéœ€é‡æ–°å¯¼å…¥ï¼‰`;
            } catch (err) {
                el.statusPill.textContent = 'sehao è§£æå¤±è´¥';
                alert(err.message || String(err));
            }
        });

        el.imgFile.addEventListener('change', () => {
            const f = el.imgFile.files?.[0];
            if (!f) return;
            const url = URL.createObjectURL(f);
            const img = new Image();
            img.onload = () => { URL.revokeObjectURL(url); openCrop(img); };
            img.src = url;
            el.statusPill.textContent = 'å·²é€‰æ‹©å›¾ç‰‡ï¼ˆå¾…è£å‰ªï¼‰';
        });

        el.csvFile.addEventListener('change', async () => {
            const f = el.csvFile.files?.[0];
            if (!f) return;
            const text = await f.text();
            try {
                const { W, H, rows } = parseCodeCSV(text);
                el.gridW.value = W; el.gridH.value = H;
                el.autoFit.checked = false;
                buildFromCSV(rows, W, H);
            } catch (err) {
                el.statusPill.textContent = 'CSV è§£æå¤±è´¥';
                alert(err.message || String(err));
            }
        });

        /**********************
         * Init
         **********************/
        // 1) å®‰è£…æŒ‰é’®é˜²è¿ç‚¹æ”¾å¤§
        installNoDoubleTapZoomForButtons();

        // 2) è¿˜åŸé¢æ¿éšè—çŠ¶æ€
        const panelHidden = localStorage.getItem('panel_hidden') === '1';
        setPanelHidden(panelHidden);

        // 3) æ›´æ–° FAB æ–‡æ¡ˆ
        updateFabOnlyText();

        // 4) canvas åˆå§‹åŒ–
        resizeViewCanvas();
        requestDraw();
    </script>
</body>

</html>
