<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
    <title>拼豆辅助 - 逐格高亮定位</title>
    <style>
        :root {
            --border: #ddd;
            --bg: #fafafa;
            --panel: #fff;
            --text: #222;
            --muted: #666;
            --r: 16px;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            font-family: system-ui, -apple-system, "Segoe UI", Roboto, "PingFang SC", "Microsoft YaHei", sans-serif;
            color: var(--text);
        }

        #app {
            height: 100%;
            display: grid;
            grid-template-rows: auto 1fr;
        }

        #top {
            padding: 10px;
            background: var(--bg);
            border-bottom: 1px solid var(--border);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        #top input,
        #top button,
        #top select {
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 12px;
            background: #fff;
        }

        #top button {
            cursor: pointer;
        }

        #top button.primary {
            border-color: #555;
            font-weight: 700;
        }

        #top .sep {
            width: 1px;
            height: 28px;
            background: var(--border);
            margin: 0 2px;
        }

        #status {
            font-size: 12px;
            color: #444;
            min-width: 200px;
        }

        #main {
            min-height: 0;
            display: grid;
            grid-template-columns: 320px 1fr;
        }

        #left {
            border-right: 1px solid var(--border);
            background: var(--panel);
            min-height: 0;
            display: grid;
            grid-template-rows: auto 1fr auto;
        }

        #leftHead {
            padding: 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #leftHead .row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        #palette {
            overflow: auto;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .sw {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 999px;
            cursor: pointer;
            user-select: none;
        }

        .sw.active {
            border-color: #000;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, .08) inset;
        }

        .swL {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .dot {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            border: 1px solid #aaa;
            flex: 0 0 auto;
        }

        .meta {
            font-size: 12px;
            color: var(--muted);
        }

        #leftFoot {
            padding: 10px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            align-items: center;
        }

        #wrap {
            position: relative;
            overflow: hidden;
            background: #f1f1f1;
        }

        canvas {
            width: 100%;
            height: 100%;
            display: block;
            touch-action: none;
        }

        @media (max-width: 900px) {
            #main {
                grid-template-columns: 1fr;
            }

            #left {
                border-right: none;
                border-bottom: 1px solid var(--border);
            }

            #palette {
                flex-direction: row;
                flex-wrap: nowrap;
                overflow: auto;
            }

            .sw {
                min-width: 220px;
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="top">
            <input id="file" type="file" accept="image/*">
            <label>行 <input id="rows" type="number" value="100" min="1" max="400"
                    style="width:90px"></label>
            <label>列 <input id="cols" type="number" value="100" min="1" max="400"
                    style="width:90px"></label>
            <label>颜色K
                <input id="k" type="number" value="24" min="2" max="64" style="width:90px">
            </label>
            <button id="gen" class="primary">生成图案</button>

            <div class="sep"></div>

            <label>顺序
                <select id="order">
                    <option value="scan">从左到右扫描</option>
                    <option value="snake">蛇形扫描</option>
                </select>
            </label>

            <button id="prevCell">上一格</button>
            <button id="nextCell" class="primary">下一格</button>
            <button id="markDone">标记完成并下一格</button>

            <div class="sep"></div>

            <button id="fit">适配窗口</button>
            <button id="zoomIn">＋</button>
            <button id="zoomOut">－</button>

            <div class="sep"></div>

            <button id="toggleEdit">编辑模式：关</button>
            <button id="clearDone">清空进度</button>

            <span id="status">请选择一张图片 → 设置行列/K → 生成图案</span>
        </div>

        <div id="main">
            <div id="left">
                <div id="leftHead">
                    <div class="row">
                        <strong>调色板</strong>
                        <span class="meta" id="palMeta">未生成</span>
                    </div>
                    <div class="row meta">
                        提示：先点选一种颜色，然后点“下一格”逐个定位。<br>
                        快捷键：N=下一格，P=上一格，Space=完成并下一格，E=编辑模式
                    </div>
                </div>

                <div id="palette"></div>

                <div id="leftFoot" class="meta">
                    点击格子：<span id="tapInfo">标记完成</span>（编辑模式开启时=改色）
                </div>
            </div>

            <div id="wrap">
                <canvas id="c"></canvas>
            </div>
        </div>
    </div>

    <script>
        (() => {
            const el = {
                file: document.getElementById('file'),
                rows: document.getElementById('rows'),
                cols: document.getElementById('cols'),
                k: document.getElementById('k'),
                gen: document.getElementById('gen'),
                order: document.getElementById('order'),
                prevCell: document.getElementById('prevCell'),
                nextCell: document.getElementById('nextCell'),
                markDone: document.getElementById('markDone'),
                fit: document.getElementById('fit'),
                zoomIn: document.getElementById('zoomIn'),
                zoomOut: document.getElementById('zoomOut'),
                toggleEdit: document.getElementById('toggleEdit'),
                clearDone: document.getElementById('clearDone'),
                status: document.getElementById('status'),
                palette: document.getElementById('palette'),
                palMeta: document.getElementById('palMeta'),
                tapInfo: document.getElementById('tapInfo'),
                c: document.getElementById('c'),
            };
            const ctx = el.c.getContext('2d');

            // 视图变换：cell-space -> canvas
            let view = { scale: 8, ox: 0, oy: 0 }; // scale: 每个格子的像素尺寸（CSS像素）
            let img = null;

            // 网格
            let ROWS = 100, COLS = 100;
            let idxMap = null;          // Uint16Array, 每格 palette index
            let done = null;            // Uint8Array, 1=done
            let palette = [];           // [{r,g,b,count,remain}]
            let activePal = 0;

            // 逐格高亮
            let seq = [];               // 当前颜色的格子索引列表（按顺序）
            let seqPos = 0;             // 当前指针
            let cursor = -1;            // 当前高亮格子 idx（r*COLS+c）

            // 渲染优化：用“像素级”pattern画布
            let patCanvas = null, patCtx = null, patImage = null;
            let doneCanvas = null, doneCtx = null, doneImage = null;

            // 模式
            let editMode = false; // true: 点格子改色；false: 点格子标记done
            let dragging = false;
            let last = { x: 0, y: 0 };
            const pointers = new Map();

            function setStatus(t) { el.status.textContent = t; }
            function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
            function clampInt(v, a, b) { v = v | 0; return Math.max(a, Math.min(b, v)); }

            function resizeCanvas() {
                const r = el.c.getBoundingClientRect();
                el.c.width = Math.max(1, Math.floor(r.width * devicePixelRatio));
                el.c.height = Math.max(1, Math.floor(r.height * devicePixelRatio));
                requestDraw();
            }
            window.addEventListener('resize', resizeCanvas);

            let raf = null;
            function requestDraw() {
                if (raf) return;
                raf = requestAnimationFrame(() => { raf = null; draw(); });
            }

            function cellToCanvas(x, y) {
                // x,y in cell space
                return {
                    x: (x * view.scale + view.ox) * devicePixelRatio,
                    y: (y * view.scale + view.oy) * devicePixelRatio
                };
            }
            function canvasToCell(cx, cy) {
                // cx,cy are CSS px
                return {
                    x: (cx - view.ox) / view.scale,
                    y: (cy - view.oy) / view.scale
                };
            }

            function fitToView() {
                if (!idxMap) return;
                const r = el.c.getBoundingClientRect();
                const sx = r.width / COLS;
                const sy = r.height / ROWS;
                view.scale = Math.max(2, Math.floor(Math.min(sx, sy) * 0.98));
                view.ox = (r.width - COLS * view.scale) / 2;
                view.oy = (r.height - ROWS * view.scale) / 2;
                requestDraw();
            }

            function zoomAt(cx, cy, factor) {
                const before = canvasToCell(cx, cy);
                view.scale = clamp(view.scale * factor, 2, 80);
                const after = cellToCanvas(before.x, before.y);
                const ax = after.x / devicePixelRatio;
                const ay = after.y / devicePixelRatio;
                view.ox += (cx - ax);
                view.oy += (cy - ay);
                requestDraw();
            }

            function centerOnCell(index) {
                if (index < 0) return;
                const r = el.c.getBoundingClientRect();
                const c = index % COLS;
                const rr = Math.floor(index / COLS);
                const targetX = (c + 0.5);
                const targetY = (rr + 0.5);
                view.ox = r.width / 2 - targetX * view.scale;
                view.oy = r.height / 2 - targetY * view.scale;
                requestDraw();
            }

            function buildPatternCanvas() {
                patCanvas = document.createElement('canvas');
                patCanvas.width = COLS;
                patCanvas.height = ROWS;
                patCtx = patCanvas.getContext('2d', { willReadFrequently: true });
                const id = patCtx.createImageData(COLS, ROWS);
                const d = id.data;
                for (let i = 0; i < idxMap.length; i++) {
                    const pi = idxMap[i];
                    const p = palette[pi];
                    const x = i % COLS;
                    const y = Math.floor(i / COLS);
                    const o = (y * COLS + x) * 4;
                    d[o] = p.r; d[o + 1] = p.g; d[o + 2] = p.b; d[o + 3] = 255;
                }
                patCtx.putImageData(id, 0, 0);
                patImage = id;

                // done overlay canvas (semi-transparent black pixel at done)
                doneCanvas = document.createElement('canvas');
                doneCanvas.width = COLS;
                doneCanvas.height = ROWS;
                doneCtx = doneCanvas.getContext('2d', { willReadFrequently: true });
                const id2 = doneCtx.createImageData(COLS, ROWS);
                const e = id2.data;
                for (let i = 0; i < done.length; i++) {
                    if (!done[i]) continue;
                    const x = i % COLS;
                    const y = (i / COLS) | 0;
                    const o = (y * COLS + x) * 4;
                    e[o] = 0; e[o + 1] = 0; e[o + 2] = 0; e[o + 3] = 120;
                }
                doneCtx.putImageData(id2, 0, 0);
                doneImage = id2;
            }

            function updateOneCellInPattern(index) {
                if (!patCtx || !doneCtx) return;
                const x = index % COLS;
                const y = (index / COLS) | 0;

                // update pattern pixel
                const pi = idxMap[index];
                const p = palette[pi];
                const id = patCtx.getImageData(x, y, 1, 1);
                id.data[0] = p.r; id.data[1] = p.g; id.data[2] = p.b; id.data[3] = 255;
                patCtx.putImageData(id, x, y);

                // update done pixel
                const id2 = doneCtx.getImageData(x, y, 1, 1);
                if (done[index]) {
                    id2.data[0] = 0; id2.data[1] = 0; id2.data[2] = 0; id2.data[3] = 120;
                } else {
                    id2.data[0] = 0; id2.data[1] = 0; id2.data[2] = 0; id2.data[3] = 0;
                }
                doneCtx.putImageData(id2, x, y);
            }

            function draw() {
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.clearRect(0, 0, el.c.width, el.c.height);
                ctx.fillStyle = '#f1f1f1';
                ctx.fillRect(0, 0, el.c.width, el.c.height);

                if (!idxMap || !patCanvas) return;

                // draw pattern (nearest-neighbor)
                ctx.save();
                ctx.imageSmoothingEnabled = false;
                const p0 = cellToCanvas(0, 0);
                const w = COLS * view.scale * devicePixelRatio;
                const h = ROWS * view.scale * devicePixelRatio;
                ctx.drawImage(patCanvas, p0.x, p0.y, w, h);

                // done overlay
                ctx.drawImage(doneCanvas, p0.x, p0.y, w, h);
                ctx.restore();

                // grid lines (only when zoom big enough)
                if (view.scale >= 10) {
                    const alpha = Math.min(0.5, Math.max(0.12, view.scale / 40));
                    ctx.save();
                    ctx.strokeStyle = `rgba(0,0,0,${alpha})`;
                    ctx.lineWidth = Math.max(1, devicePixelRatio);
                    // draw visible grid lines only
                    const r = el.c.getBoundingClientRect();
                    const leftCell = Math.floor((0 - view.ox) / view.scale);
                    const rightCell = Math.ceil((r.width - view.ox) / view.scale);
                    const topCell = Math.floor((0 - view.oy) / view.scale);
                    const botCell = Math.ceil((r.height - view.oy) / view.scale);

                    const c0 = clampInt(leftCell, 0, COLS);
                    const c1 = clampInt(rightCell, 0, COLS);
                    const r0 = clampInt(topCell, 0, ROWS);
                    const r1 = clampInt(botCell, 0, ROWS);

                    for (let c = c0; c <= c1; c++) {
                        const x = cellToCanvas(c, 0).x;
                        const y0 = cellToCanvas(0, r0).y;
                        const y1 = cellToCanvas(0, r1).y;
                        ctx.beginPath(); ctx.moveTo(x, y0); ctx.lineTo(x, y1); ctx.stroke();
                    }
                    for (let rr = r0; rr <= r1; rr++) {
                        const y = cellToCanvas(0, rr).y;
                        const x0 = cellToCanvas(c0, 0).x;
                        const x1 = cellToCanvas(c1, 0).x;
                        ctx.beginPath(); ctx.moveTo(x0, y); ctx.lineTo(x1, y); ctx.stroke();
                    }
                    ctx.restore();
                }

                // cursor highlight
                if (cursor >= 0) {
                    const c = cursor % COLS;
                    const rr = (cursor / COLS) | 0;
                    const a = cellToCanvas(c, rr);
                    const size = view.scale * devicePixelRatio;
                    ctx.save();
                    ctx.strokeStyle = 'rgba(255,255,0,0.98)';
                    ctx.lineWidth = Math.max(4, 3 * devicePixelRatio);
                    ctx.strokeRect(a.x, a.y, size, size);
                    ctx.restore();
                }
            }

            function renderPalette() {
                el.palette.innerHTML = '';
                el.palMeta.textContent = palette.length ? `${palette.length} 色` : '未生成';

                palette.forEach((p, i) => {
                    const sw = document.createElement('div');
                    sw.className = 'sw' + (i === activePal ? ' active' : '');
                    const left = document.createElement('div');
                    left.className = 'swL';

                    const dot = document.createElement('div');
                    dot.className = 'dot';
                    dot.style.background = `rgb(${p.r},${p.g},${p.b})`;

                    const t = document.createElement('div');
                    t.innerHTML = `<div><strong>色 ${i + 1}</strong> <span class="meta">剩余 ${p.remain}</span></div>
                     <div class="meta">总数 ${p.count}</div>`;

                    left.appendChild(dot);
                    left.appendChild(t);

                    const right = document.createElement('div');
                    right.className = 'meta';
                    right.textContent = (p.remain === 0 ? '✓' : '');

                    sw.appendChild(left);
                    sw.appendChild(right);

                    sw.onclick = () => {
                        activePal = i;
                        buildSequenceForActiveColor(true);
                        renderPalette();
                        requestDraw();
                    };
                    el.palette.appendChild(sw);
                });
            }

            function rebuildCounts() {
                palette.forEach(p => { p.count = 0; p.remain = 0; });
                for (let i = 0; i < idxMap.length; i++) {
                    const pi = idxMap[i];
                    palette[pi].count++;
                    if (!done[i]) palette[pi].remain++;
                }
            }

            function buildSequenceForActiveColor(resetPos) {
                if (!idxMap) return;
                const key = activePal;
                const list = [];
                // collect all cells of this color that are NOT done
                for (let i = 0; i < idxMap.length; i++) {
                    if (idxMap[i] === key && !done[i]) list.push(i);
                }
                // order
                const mode = el.order.value;
                if (mode === 'scan') {
                    // already scanline (increasing idx)
                } else if (mode === 'snake') {
                    // sort by row then snake columns
                    list.sort((a, b) => {
                        const ra = (a / COLS) | 0, rb = (b / COLS) | 0;
                        if (ra !== rb) return ra - rb;
                        const ca = a % COLS, cb = b % COLS;
                        if (ra % 2 === 0) return ca - cb;
                        return cb - ca;
                    });
                }

                seq = list;
                if (resetPos) seqPos = 0;

                if (seq.length) {
                    cursor = seq[seqPos];
                    centerOnCell(cursor);
                    setStatus(`色 ${activePal + 1}：剩余 ${palette[activePal].remain}，定位到第 ${seqPos + 1}/${seq.length} 个`);
                } else {
                    cursor = -1;
                    setStatus(`色 ${activePal + 1}：已完成（或无此颜色）`);
                }
            }

            function nextCell() {
                if (!seq.length) return;
                seqPos = clampInt(seqPos + 1, 0, seq.length - 1);
                cursor = seq[seqPos];
                centerOnCell(cursor);
                setStatus(`色 ${activePal + 1}：定位到第 ${seqPos + 1}/${seq.length} 个`);
                requestDraw();
            }
            function prevCell() {
                if (!seq.length) return;
                seqPos = clampInt(seqPos - 1, 0, seq.length - 1);
                cursor = seq[seqPos];
                centerOnCell(cursor);
                setStatus(`色 ${activePal + 1}：定位到第 ${seqPos + 1}/${seq.length} 个`);
                requestDraw();
            }

            function toggleDoneAndAdvance(index) {
                if (index < 0) return;
                done[index] = done[index] ? 0 : 1;
                updateOneCellInPattern(index);
                rebuildCounts();
                renderPalette();
                // rebuild seq because remain changed
                buildSequenceForActiveColor(false);
                // 如果当前格子刚刚被完成，自动跳到下一格（更符合你的节奏）
                if (done[index] && seq.length) {
                    // cursor 可能还指向这个已完成格子，需要把它从 seq 里剔除后移动
                    buildSequenceForActiveColor(true);
                }
                saveProgress();
                requestDraw();
            }

            // ---------- 生成图案：从图片缩放到 ROWS×COLS，然后 KMeans 量化 ----------
            async function generateFromImage() {
                if (!img) { setStatus('请先选择图片'); return; }

                ROWS = clampInt(parseInt(el.rows.value, 10), 1, 400);
                COLS = clampInt(parseInt(el.cols.value, 10), 1, 400);
                el.rows.value = ROWS; el.cols.value = COLS;

                const K = clampInt(parseInt(el.k.value, 10), 2, 64);
                el.k.value = K;

                setStatus('缩放采样中…');

                // 1) draw image into small canvas (COLS×ROWS)
                const s = document.createElement('canvas');
                s.width = COLS; s.height = ROWS;
                const sctx = s.getContext('2d', { willReadFrequently: true });
                sctx.imageSmoothingEnabled = true;
                sctx.drawImage(img, 0, 0, COLS, ROWS);
                const data = sctx.getImageData(0, 0, COLS, ROWS).data;

                // 2) build samples (RGB)
                const pixels = new Float32Array(ROWS * COLS * 3);
                for (let i = 0; i < ROWS * COLS; i++) {
                    pixels[i * 3] = data[i * 4];
                    pixels[i * 3 + 1] = data[i * 4 + 1];
                    pixels[i * 3 + 2] = data[i * 4 + 2];
                }

                setStatus(`颜色量化中…（K=${K}）`);
                const { centers, labels } = await kmeansQuantize(pixels, K);

                // 3) build palette + idxMap
                palette = centers.map(c => ({ r: Math.round(c[0]), g: Math.round(c[1]), b: Math.round(c[2]), count: 0, remain: 0 }));
                idxMap = new Uint16Array(ROWS * COLS);
                for (let i = 0; i < labels.length; i++) idxMap[i] = labels[i];

                done = loadProgressOrInit();
                rebuildCounts();

                // 4) re-order palette by remain desc (optional)
                //    (同时重映射 idxMap)
                remapPaletteByRemain();

                // 5) build render buffers
                buildPatternCanvas();

                activePal = 0;
                renderPalette();
                fitToView();
                buildSequenceForActiveColor(true);
                requestDraw();
                setStatus(`完成：${ROWS}×${COLS}，${palette.length} 色。选色 → “下一格”逐个定位`);
            }

            function remapPaletteByRemain() {
                const order = palette.map((p, i) => ({ i, remain: p.remain })).sort((a, b) => b.remain - a.remain);
                const mapOldToNew = new Map(order.map((o, newI) => [o.i, newI]));
                const newPal = order.map(o => palette[o.i]);
                const newIdx = new Uint16Array(idxMap.length);
                for (let i = 0; i < idxMap.length; i++) newIdx[i] = mapOldToNew.get(idxMap[i]);
                palette = newPal;
                idxMap = newIdx;
            }

            // 简易 k-means（对 100×100 这类规模很够用）
            async function kmeansQuantize(pixels, K) {
                const n = pixels.length / 3;

                // 初始化：随机选 K 个像素做中心
                const centers = [];
                for (let k = 0; k < K; k++) {
                    const idx = (Math.random() * n) | 0;
                    centers.push([pixels[idx * 3], pixels[idx * 3 + 1], pixels[idx * 3 + 2]]);
                }

                const labels = new Uint16Array(n);
                const iters = 10;

                for (let it = 0; it < iters; it++) {
                    // assign
                    for (let i = 0; i < n; i++) {
                        const r = pixels[i * 3], g = pixels[i * 3 + 1], b = pixels[i * 3 + 2];
                        let best = 0, bestD = 1e18;
                        for (let k = 0; k < K; k++) {
                            const c = centers[k];
                            const dr = r - c[0], dg = g - c[1], db = b - c[2];
                            const d = dr * dr + dg * dg + db * db;
                            if (d < bestD) { bestD = d; best = k; }
                        }
                        labels[i] = best;
                    }

                    // update
                    const sr = new Float64Array(K);
                    const sg = new Float64Array(K);
                    const sb = new Float64Array(K);
                    const cnt = new Uint32Array(K);

                    for (let i = 0; i < n; i++) {
                        const k = labels[i];
                        sr[k] += pixels[i * 3];
                        sg[k] += pixels[i * 3 + 1];
                        sb[k] += pixels[i * 3 + 2];
                        cnt[k]++;
                    }

                    for (let k = 0; k < K; k++) {
                        if (cnt[k] === 0) {
                            const idx = (Math.random() * n) | 0;
                            centers[k] = [pixels[idx * 3], pixels[idx * 3 + 1], pixels[idx * 3 + 2]];
                        } else {
                            centers[k] = [sr[k] / cnt[k], sg[k] / cnt[k], sb[k] / cnt[k]];
                        }
                    }

                    setStatus(`颜色量化中…迭代 ${it + 1}/${iters}`);
                    // 让 UI 有机会刷新
                    await new Promise(r => setTimeout(r, 0));
                }

                return { centers, labels };
            }

            // ---------- 文件加载 ----------
            el.file.addEventListener('change', async (e) => {
                const f = e.target.files?.[0];
                if (!f) return;
                img = await fileToImage(f);
                setStatus(`已载入图片：${img.width}×${img.height}。点击“生成图案”。`);
            });

            function fileToImage(file) {
                return new Promise((res, rej) => {
                    const url = URL.createObjectURL(file);
                    const im = new Image();
                    im.onload = () => { URL.revokeObjectURL(url); res(im); };
                    im.onerror = rej;
                    im.src = url;
                });
            }

            // ---------- 交互：缩放/拖拽/点击 ----------
            el.c.addEventListener('wheel', (e) => {
                if (!idxMap) return;
                e.preventDefault();
                const r = el.c.getBoundingClientRect();
                const cx = e.clientX - r.left;
                const cy = e.clientY - r.top;
                zoomAt(cx, cy, Math.exp(-e.deltaY * 0.0012));
            }, { passive: false });

            el.c.addEventListener('pointerdown', (e) => {
                el.c.setPointerCapture(e.pointerId);
                pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

                if (pointers.size === 1) {
                    dragging = true;
                    last = { x: e.clientX, y: e.clientY };
                }
            });

            el.c.addEventListener('pointermove', (e) => {
                if (!pointers.has(e.pointerId)) return;
                pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

                if (!idxMap) return;

                if (pointers.size === 2) {
                    const arr = Array.from(pointers.values());
                    const d = Math.hypot(arr[0].x - arr[1].x, arr[0].y - arr[1].y);
                    if (!el.c._pinch) {
                        el.c._pinch = { d0: d, s0: view.scale, cx: (arr[0].x + arr[1].x) / 2, cy: (arr[0].y + arr[1].y) / 2 };
                    }
                    const f = d / el.c._pinch.d0;
                    const target = clamp(el.c._pinch.s0 * f, 2, 80);
                    const r = el.c.getBoundingClientRect();
                    const cx = el.c._pinch.cx - r.left;
                    const cy = el.c._pinch.cy - r.top;
                    const before = canvasToCell(cx, cy);
                    view.scale = target;
                    const after = cellToCanvas(before.x, before.y);
                    view.ox += (cx - after.x / devicePixelRatio);
                    view.oy += (cy - after.y / devicePixelRatio);
                    requestDraw();
                    return;
                } else {
                    el.c._pinch = null;
                }

                if (!dragging) return;
                const dx = e.clientX - last.x;
                const dy = e.clientY - last.y;
                last = { x: e.clientX, y: e.clientY };
                view.ox += dx;
                view.oy += dy;
                requestDraw();
            });

            el.c.addEventListener('pointerup', (e) => {
                pointers.delete(e.pointerId);
                if (pointers.size < 2) el.c._pinch = null;

                if (!idxMap) { dragging = false; return; }

                // 点击（非拖拽）
                const r = el.c.getBoundingClientRect();
                const cx = e.clientX - r.left;
                const cy = e.clientY - r.top;
                const p = canvasToCell(cx, cy);
                const c = Math.floor(p.x);
                const rr = Math.floor(p.y);

                // 很小移动也当点击
                dragging = false;

                if (c < 0 || c >= COLS || rr < 0 || rr >= ROWS) return;
                const index = rr * COLS + c;

                if (editMode) {
                    // 改色：把这个格子改成当前选中的颜色
                    idxMap[index] = activePal;
                    updateOneCellInPattern(index);
                    rebuildCounts();
                    renderPalette();
                    buildSequenceForActiveColor(true);
                    saveProgress();
                    cursor = index;
                    requestDraw();
                    return;
                }

                // 标记 done / undo
                cursor = index;
                toggleDoneAndAdvance(index);
            });

            // ---------- 顶部按钮 ----------
            el.gen.onclick = generateFromImage;

            el.fit.onclick = () => fitToView();
            el.zoomIn.onclick = () => {
                const r = el.c.getBoundingClientRect();
                zoomAt(r.width / 2, r.height / 2, 1.15);
            };
            el.zoomOut.onclick = () => {
                const r = el.c.getBoundingClientRect();
                zoomAt(r.width / 2, r.height / 2, 1 / 1.15);
            };

            el.nextCell.onclick = () => nextCell();
            el.prevCell.onclick = () => prevCell();
            el.markDone.onclick = () => {
                if (cursor < 0) buildSequenceForActiveColor(true);
                if (cursor >= 0) {
                    if (!done[cursor]) done[cursor] = 1;
                    updateOneCellInPattern(cursor);
                    rebuildCounts();
                    renderPalette();
                    saveProgress();
                    buildSequenceForActiveColor(true);
                    requestDraw();
                }
            };

            el.order.onchange = () => buildSequenceForActiveColor(true);

            el.toggleEdit.onclick = () => {
                editMode = !editMode;
                el.toggleEdit.textContent = `编辑模式：${editMode ? '开' : '关'}`;
                el.tapInfo.textContent = editMode ? '改色' : '标记完成';
                setStatus(editMode ? '编辑模式：点格子改成当前颜色' : '定位模式：点格子标记完成');
            };

            el.clearDone.onclick = () => {
                if (!done) return;
                done.fill(0);
                // rebuild done canvas
                buildPatternCanvas();
                rebuildCounts();
                renderPalette();
                buildSequenceForActiveColor(true);
                saveProgress();
                setStatus('已清空进度');
                requestDraw();
            };

            // ---------- 快捷键 ----------
            window.addEventListener('keydown', (e) => {
                if (!idxMap) return;
                if (e.key === 'n' || e.key === 'N') { nextCell(); e.preventDefault(); }
                if (e.key === 'p' || e.key === 'P') { prevCell(); e.preventDefault(); }
                if (e.key === ' ') {
                    e.preventDefault();
                    if (cursor < 0) buildSequenceForActiveColor(true);
                    if (cursor >= 0) {
                        if (!done[cursor]) done[cursor] = 1;
                        updateOneCellInPattern(cursor);
                        rebuildCounts(); renderPalette(); saveProgress();
                        buildSequenceForActiveColor(true);
                        requestDraw();
                    }
                }
                if (e.key === 'e' || e.key === 'E') {
                    editMode = !editMode;
                    el.toggleEdit.textContent = `编辑模式：${editMode ? '开' : '关'}`;
                    el.tapInfo.textContent = editMode ? '改色' : '标记完成';
                    e.preventDefault();
                }
            });

            // ---------- 进度保存（done + 当前设置） ----------
            function key() {
                return `beads_progress_v1_${ROWS}x${COLS}`;
            }
            function loadProgressOrInit() {
                try {
                    const s = localStorage.getItem(key());
                    if (!s) return new Uint8Array(ROWS * COLS);
                    const obj = JSON.parse(s);
                    if (!obj || !obj.done || obj.done.length !== ROWS * COLS) return new Uint8Array(ROWS * COLS);
                    return Uint8Array.from(obj.done);
                } catch {
                    return new Uint8Array(ROWS * COLS);
                }
            }
            function saveProgress() {
                try {
                    localStorage.setItem(key(), JSON.stringify({ done: Array.from(done) }));
                } catch { }
            }

            // init
            resizeCanvas();
        })();
    </script>
</body>

</html>
